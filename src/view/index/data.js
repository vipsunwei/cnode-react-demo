export default { 'success': true, 'data': [{ 'id': '5cbfd9aca86ae80ce64b3175', 'author_id': '4f447c2f0a8abae26e01b27d', 'tab': 'share', 'content': '<div class="markdown-text"><h2>前言</h2>\n<p>时隔一年，Node.js 12 如约而至，正式发布第一个 <a href="https://github.com/nodejs/Release">Current</a> 版本。</p>\n<p>该版本带来了诸如：</p>\n<ul>\n<li>V8 更新带来好多不错的特性。</li>\n<li>HTTP 解析速度提升。</li>\n<li>启动速度大幅提升。</li>\n<li>更好的诊断报告和堆分析工具。</li>\n<li>ESM 模块更新。</li>\n</ul>\n<p>原文地址：<a href="https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f">https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f</a>\n语雀地址：<a href="https://www.yuque.com/egg/nodejs/nodejs-12">https://www.yuque.com/egg/nodejs/nodejs-12</a></p>\n<h2>LTS vs Current</h2>\n<p><img src="https://cdn.nlark.com/yuque/0/2019/png/84182/1556074709431-35af45b8-ec7a-4a81-83d8-155eb519f04a.png#align=left&amp;display=inline&amp;height=389&amp;name=image.png&amp;originHeight=500&amp;originWidth=960&amp;size=58313&amp;status=done&amp;width=746" alt="image.png"></p>\n<p>如果你不了解 Node.js 的  Long Term Support 发布策略的话，一定要看看 <a href="https://github.com/nodejs/Release">https://github.com/nodejs/Release</a> 。</p>\n<p>就目前而言，Node.js 6.x 和 8.x 将在 2019 年末结束 LTS 的支持，大家尽快升级到 10.x 吧。</p>\n<h2>快速体验</h2>\n<pre class="prettyprint language-bash"><code>$ nvs add node&#x2F;12\n$ nvs use 12\n$ node -v\nv12.0.0\n</code></pre><p>具体参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/63403762">科普文：使用 nvs 管理本地 Node.js 版本</a></p>\n<h2>V8 更新到 7.4</h2>\n<blockquote>\n<p>大部分情况下，我们不用去考虑性能问题，坐等 V8 版本更新就好了。（大雾）</p>\n</blockquote>\n<p>本次版本更新，也带来了好几个不错的特性：</p>\n<ul>\n<li><a href="https://v8.dev/blog/v8-release-72#async-stack-traces">异步堆栈跟踪</a></li>\n<li><a href="https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch">参数调用不匹配时的调用速度优化</a></li>\n<li><a href="https://v8.dev/blog/v8-release-73#faster-await">更快的 await</a></li>\n<li><a href="https://v8.dev/blog/v8-release-72#javascript-parsing">更快的 JavaScript 解析速度</a></li>\n</ul>\n<p><strong>同时，跑了下我们 Egg 的一些内部测试，发现序列化有 10~20% 的性能提升，恐怖如斯！</strong></p>\n<p>另，奇丑无比的 <a href="https://github.com/tc39/proposal-class-fields">Private Class Fields</a> 也能用了：</p>\n<pre class="prettyprint language-javascript"><code>class IncreasingCounter {\n  #count = 0;\n  \n  get value() {\n    console.log(&#x27;Getting the current value!&#x27;);\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n</code></pre><h2>HTTP 解析速度提升</h2>\n<p>默认的 HTTP 解析器切换为 <a href="https://github.com/nodejs/llhttp">llhttp</a> ，性能提升恐怖如斯：</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2019/png/84182/1556072499637-686bb0e3-c75c-424c-851f-ad88aff183a2.png#align=left&amp;display=inline&amp;height=231&amp;name=image.png&amp;originHeight=404&amp;originWidth=1302&amp;size=88775&amp;status=done&amp;width=746" alt="image.png"></p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>启动速度提升</h2>\n<p>通过 <a href="https://v8.dev/blog/code-caching">v8 code cache</a> 的支持，<a href="https://github.com/nodejs/node/pull/27161">在构建时提前为内置库生成代码缓存</a>，从而提升 30% 的启动耗时。\n同时，通过<a href="https://github.com/nodejs/node/pull/24950">重用主进程缓存</a>，Workers Threads 的启动速度提升了 60% 。</p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>Workers Threads</h2>\n<p>在 10.x 已经引入的 <a href="https://nodejs.org/api/worker_threads.html">Workers Threads</a> 特性，在 12.x 里面默认启用，无需使用 <code>--experimental-worker</code> 开启。同时基于上一条的介绍，启动的速度也得到大幅提升。</p>\n<p>相关介绍：<a href="https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6">https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6</a></p>\n<h2>诊断报告</h2>\n<p>提供了新的实验性功能『诊断报告』，一个非常有用的特性。\n可用于帮助分析诸如：崩溃，性能问题，内存泄漏，高 CPU 占用等等问题。详见 <a href="https://medium.com/the-node-js-collection/easily-identify-problems-in-node-js-applications-with-diagnostic-report-dc82370d8029">这篇文章</a>。</p>\n<blockquote>\n<p>点评：这也是 <a href="https://www.aliyun.com/product/nodejs">AliNode</a> 之前的一个卖点之一。</p>\n</blockquote>\n<h2>Heap Dump</h2>\n<p>以前我们分析问题的时候，需要手动安装对应的类库或者使用 AliNode。</p>\n<p>在 12.x 里面内置了该功能，详见：</p>\n<ul>\n<li><a href="https://github.com/nodejs/node/pull/27133">https://github.com/nodejs/node/pull/27133</a></li>\n<li><a href="https://github.com/nodejs/node/pull/26501">https://github.com/nodejs/node/pull/26501</a></li>\n</ul>\n<blockquote>\n<p>点评：又一个 <a href="https://www.aliyun.com/product/nodejs">AliNode</a> 的功能被内置了。但其实影响不大，AliNode 的核心在于分析平台，这块的采集能力，本来他们就打算开源回馈出去的。</p>\n</blockquote>\n<p>同时，由于上述提到的 V8 升级，现在可以按照可用内存动态调整堆大小了。</p>\n<h2>ESM 模块方案更新</h2>\n<p>ES6 模块仍然还在实验阶段，不过有了新的方式，具体参见<a href="https://medium.com/@nodejs/announcing-a-new-experimental-modules-1be8d2d6c2ff">这篇文章</a>。</p>\n<blockquote>\n<p>点评：让子弹再飞一会，该特性真的不是痛点，不急。</p>\n</blockquote>\n<h2>其他更新</h2>\n<ul>\n<li>更好的原生模块支持，<a href="https://nodejs.org/api/n-api.html#n_api_n_api">N-API</a> 升级为版本 4，并 backport 到 Node.js 8.x 和 10.x。详细参见<a href="https://medium.com/the-node-js-collection/new-features-bring-native-add-ons-close-to-being-on-par-with-js-modules-cd4f9b8e4b4">这篇文章</a>。</li>\n<li>TLS 升级为 1.3， <a href="https://developer.ibm.com/blogs/openssl-111-has-landed-in-nodejs-master-and-why-its-important-for-nodejs-lts-releases/">增强安全功能</a>。</li>\n<li>随着 C++ 编译器的更新，现在要求 <code>GCC 6</code> 和 <code>glibc 2.17</code> ，对应的操作系统 Win7 和 macOS 10，详细参见<a href="https://github.com/nodejs/node/blob/v12.x/BUILDING.md#platform-list">这篇文章</a>。</li>\n</ul>\n<p>不过目前 node-gyp 的一些原生模块会编译失败：</p>\n<pre class="prettyprint language-bash"><code>nunjucks@3.2.0 › chokidar@2.1.5 › fsevents@^1.2.7 optional error: Error: Run &quot;sh -c node install&quot; error, exit code 1\n    at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;tz&#x2F;.npm-global&#x2F;lib&#x2F;node_modules&#x2F;tnpm&#x2F;node_modules&#x2F;_runscript@1.3.0@runscript&#x2F;index.js:74:21)\n    at ChildProcess.emit (events.js:196:13)\n    at maybeClose (internal&#x2F;child_process.js:1000:16)\n    at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:267:5)\n</code></pre></div>', 'title': 'Node 12 值得关注的新特性', 'last_reply_at': '2019-06-04T12:12:29.078Z', 'good': false, 'top': true, 'reply_count': 43, 'visit_count': 35286, 'create_at': '2019-04-24T03:36:12.582Z', 'author': { 'loginname': 'atian25', 'avatar_url': 'https://avatars2.githubusercontent.com/u/227713?v=4&s=120' } }, { 'id': '5bd4772a14e994202cd5bdb7', 'author_id': '504c28a2e2b845157708cb61', 'tab': 'share', 'content': '<div class="markdown-text"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href="/user/i5ting">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href="https://cnodejs.org/topic/57239bce5a26c4a841ecbf01">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>', 'title': '服务器迁移至 aws 日本机房', 'last_reply_at': '2019-06-03T01:29:22.108Z', 'good': false, 'top': true, 'reply_count': 190, 'visit_count': 63038, 'create_at': '2018-10-27T14:33:14.694Z', 'author': { 'loginname': 'alsotang', 'avatar_url': 'https://avatars1.githubusercontent.com/u/1147375?v=4&s=120' } }, { 'id': '5ceca8f852ccb64168ba811d', 'author_id': '5ceca6e14036f24194cf7182', 'tab': 'share', 'content': '<div class="markdown-text"><p><img src="//static.cnodejs.org/FmAjYTYlRr6nGs9y2a9NI19jUvLK" alt="1.png"></p>\n<blockquote>\n<p>一个摸鱼看书神器</p>\n</blockquote>\n<h3>地址</h3>\n<ul>\n<li><a href="https://github.com/cteams/Thief-Book">https://github.com/cteams/Thief-Book</a></li>\n<li><a href="https://marketplace.visualstudio.com/items?itemName=C-TEAM.thief-book">https://marketplace.visualstudio.com/items?itemName=C-TEAM.thief-book</a></li>\n</ul>\n<h3>默认配置</h3>\n<blockquote>\n<p>需要填写 TXT小说 路径才可以使用此插件</p>\n</blockquote>\n<ul>\n<li>当前页数：1</li>\n<li>每页长度：50</li>\n<li>TXT绝对路径：空</li>\n</ul>\n<h3>快捷键</h3>\n<blockquote>\n<p>没有设置TXT小说的本地绝对路径，会报错，会提示设置路径</p>\n</blockquote>\n<p><code>cmd+m</code> 老板键 。 随机显示不同语言的 Hello World ，随时可用</p>\n<p><code>cmd+,</code> 上一页 。 文本聚焦(编辑代码)的时候，才可以使用</p>\n<p><code>cmd+.</code> 下一页 。 文本聚焦(编辑代码)的时候，才可以使用</p>\n</div>', 'title': 'VSCode 上一款真正的摸鱼神器： Thief-Book', 'last_reply_at': '2019-06-04T12:48:15.554Z', 'good': false, 'top': false, 'reply_count': 15, 'visit_count': 1825, 'create_at': '2019-05-28T03:20:24.270Z', 'author': { 'loginname': 'lauixData', 'avatar_url': 'https://avatars1.githubusercontent.com/u/9290546?v=4&s=120' } }, { 'id': '5cf5be941fe902120f31bd4d', 'author_id': '5bc6779d37a6965f5905229a', 'tab': 'ask', 'content': '<div class="markdown-text"><p>请问前辈们，有没有egg-authz/node-casbin的完整应用范例呢？可以帮忙提供一下吗！感谢感谢~~</p>\n<p>想参考别人的代码，看看怎麽运用，站在巨人的肩膀上，学习事半功倍呀！</p>\n</div>', 'title': '请问前辈们，有没有egg-authz/node-casbin  的完整应用范例呢？想参考别人的代码，看看怎麽运用，站在巨人的肩膀上，学习事半功倍呀！', 'last_reply_at': '2019-06-04T11:36:00.620Z', 'good': false, 'top': false, 'reply_count': 1, 'visit_count': 190, 'create_at': '2019-06-04T00:43:00.541Z', 'author': { 'loginname': 'Solomonqoo', 'avatar_url': 'https://avatars3.githubusercontent.com/u/44214486?v=4&s=120' } }, { 'id': '5cf6463f1fe902120f31c143', 'author_id': '5ceca6e14036f24194cf7182', 'tab': 'share', 'content': '<div class="markdown-text"><h1>前言</h1>\n<p>之前发的帖子：<a href="https://cnodejs.org/topic/5ceca8f852ccb64168ba811d#5cf4c20295fcc914aa265988">https://cnodejs.org/topic/5ceca8f852ccb64168ba811d#5cf4c20295fcc914aa265988</a></p>\n<blockquote>\n<p>发布了 vscode 版本后好评如潮，有许多用户需要其他 编辑器版本 和 浏览器版本 等\n经过各种调研，于是就产出了 PC 版本,支持 MAC+WIN\n为了更好的隐蔽，支持透明窗口，可以完美的嵌入各种软件界面上。</p>\n</blockquote>\n<h1>介绍</h1>\n<p><strong>Thief-Book</strong> 是一款真正的<code>摸鱼神器</code>，可以更加隐秘性大胆的看小说。</p>\n<ul>\n<li><strong>隐蔽性</strong> 自定义透明背景，随意调整大小，完美融入各种软件界面</li>\n<li><strong>快捷性</strong> 三个快捷键，实现完美的摸鱼</li>\n<li><strong>跨平台</strong> 支持 Mac+Win，Linux 暂未测试，请自行打包</li>\n</ul>\n<h1>VScode</h1>\n<p>Thief-Book 为用户提供 Vscode 版本，具体请看 <a href="https://github.com/cteams/Thief-Book-VSCode">https://github.com/cteams/Thief-Book-VSCode</a></p>\n<h1>地址</h1>\n<ul>\n<li>Github :<a href="https://github.com/cteams/Thief-Book"> https://github.com/cteams/Thief-Book</a></li>\n<li>下载地址 : <a href="https://github.com/cteams/Thief-Book/releases">https://github.com/cteams/Thief-Book/releases</a></li>\n</ul>\n<h1>演示</h1>\n<h2>MAC</h2>\n<blockquote>\n<p>MAC 支持 任务栏版 + 桌面版</p>\n</blockquote>\n<p><img src="https://liu-yu.oss-cn-beijing.aliyuncs.com/tc/mac.gif" alt="mac"></p>\n<h2>WIN</h2>\n<blockquote>\n<p>WIN 只有桌面版</p>\n</blockquote>\n<p><img src="https://liu-yu.oss-cn-beijing.aliyuncs.com/tc/win.gif" alt="win"></p>\n<h1>快捷键</h1>\n<h2>MAC</h2>\n<p><strong>Cmd+Option+M</strong> 老板键</p>\n<p><strong>Cmd+Option+,</strong> 上一页</p>\n<p><strong>Cmd+Option+.</strong> 下一页</p>\n<h2>WIN</h2>\n<p><strong>Ctrl+Alt+M</strong>  老板键</p>\n<p><strong>Ctrl+Alt+,</strong> 上一页</p>\n<p><strong>Ctrl+Alt+.</strong> 下一页</p>\n<h1>TODO</h1>\n<ul>\n<li>[x] 任务栏版本</li>\n<li>[x] 桌面版本</li>\n<li>[x] 设置小说路径</li>\n<li>[x] 设置当前页数</li>\n<li>[x] 设置每页字数</li>\n<li>[x] 老板键</li>\n<li>[x] 上一页</li>\n<li>[x] 下一页</li>\n<li>[x] 英文小说支持</li>\n<li>[x] 自定义换行符号</li>\n<li>[x] 自定义桌面版背景</li>\n<li>[x] 自定义桌面版字体颜色</li>\n<li>[x] 跨平台兼容</li>\n<li>[x] 桌面版随意拖动，随意调整大小</li>\n<li>[x] 桌面版窗口永远顶置</li>\n<li>[ ] 多本小说管理</li>\n<li>[ ] 在线小说下载</li>\n<li>[ ] 股票支持</li>\n</ul>\n<h1>意见</h1>\n<p>大家有更好的意见，更好的想法，请 Github 留言</p>\n</div>', 'title': 'Thief-Book 摸鱼神器终于发布了 PC 端', 'last_reply_at': '2019-06-04T10:21:51.890Z', 'good': false, 'top': false, 'reply_count': 0, 'visit_count': 75, 'create_at': '2019-06-04T10:21:51.890Z', 'author': { 'loginname': 'lauixData', 'avatar_url': 'https://avatars1.githubusercontent.com/u/9290546?v=4&s=120' } }, { 'id': '5cc12d4537faec0ce1d06706', 'author_id': '5875bd3d06fa6e2a4e4f730b', 'tab': 'share', 'content': '<div class="markdown-text"><p><img src="//static.cnodejs.org/FsJPVoGNLeApbuZx9lRwmcv4LCfm" alt="image.png">\n前一秒还在劝人学node，后一秒就被打脸了。。。羞愧难当。。。顿时找不到理由反驳。</p>\n</div>', 'title': '一位同学因别人说node只适合中小型，放弃node学go,大家怎么看。', 'last_reply_at': '2019-06-04T10:18:20.685Z', 'good': false, 'top': false, 'reply_count': 41, 'visit_count': 4352, 'create_at': '2019-04-25T03:45:09.872Z', 'author': { 'loginname': 'zy445566', 'avatar_url': 'https://avatars2.githubusercontent.com/u/14976489?v=4&s=120' } }, { 'id': '5cf5296b95fcc914aa265c77', 'author_id': '5b0eaaf38a4f51e140d9437d', 'tab': 'share', 'content': '<div class="markdown-text"><h2>需求背景</h2>\n<p>实现全链路日志追踪，便于日志监控、问题排查、接口响应耗时数据统计等，首先 API 接口服务接收到调用方请求，根据调用方传的 traceId，在该次调用链中处理业务时，如需打印日志的，日志信息按照约定的规范进行打印，并记录 traceId，实现日志链路追踪。</p>\n<ul>\n<li><strong>日志路径约定</strong></li>\n</ul>\n<pre class="prettyprint"><code>&#x2F;var&#x2F;logs&#x2F;${projectName}&#x2F;bizLog&#x2F;${projectName}-yyyyMMdd.log\n</code></pre><ul>\n<li><strong>日志格式约定</strong></li>\n</ul>\n<pre class="prettyprint language-bash"><code>日志时间[]traceId[]服务端IP[]客户端IP[]日志级别[]日志内容\n</code></pre><p>采用 Egg.js 框架 egg-logger 中间件，在实现过程中发现对于按照以上日志格式打印是无法满足需求的（至少目前我还没找到可实现方式），如果要自己实现，可能要自己造轮子了，好在官方的  egg-logger 中间件提供了自定义日志扩展功能，参考 <a href="https://eggjs.org/zh-cn/core/logger.html#%E9%AB%98%E7%BA%A7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97">高级自定义日志</a>，本身也提供了日志分割、多进程日志处理等功能。</p>\n<p>egg-logger 提供了多种传输通道，我们的需求主要是对请求的业务日志自定义格式存储，主要用到 fileTransport 和 consoleTransport 两个通道，分别打印日志到文件和终端。</p>\n<h2>自定义日志插件开发</h2>\n<p>基于 egg-logger 定制开发一个插件项目，参考 <a href="https://eggjs.org/zh-cn/advanced/plugin.html">插件开发</a>，以下以 egg-logger-custom 为项目，展示核心代码编写</p>\n<ul>\n<li><strong>编写logger.js</strong></li>\n</ul>\n<blockquote>\n<p>egg-logger-custom/lib/logger.js</p>\n</blockquote>\n<pre class="prettyprint language-js"><code>const moment = require(&#x27;moment&#x27;);\nconst FileTransport = require(&#x27;egg-logger&#x27;).FileTransport;\nconst utils = require(&#x27;.&#x2F;utils&#x27;);\nconst util = require(&#x27;util&#x27;);\n\n&#x2F;**\n * 继承 FileTransport\n *&#x2F;\nclass AppTransport extends FileTransport {\n    constructor(options, ctx) {\n        super(options);\n\n        this.ctx = ctx; &#x2F;&#x2F; 得到每次请求的上下文\n    }\n\n    log(level, args, meta) {\n        &#x2F;&#x2F; 获取自定义格式消息\n        const customMsg = this.messageFormat({\n            level,\n        });\n\n        &#x2F;&#x2F; 针对 Error 消息打印出错误的堆栈\n        if (args[0] instanceof Error) {\n            const err = args[0] || {};\n            args[0] = util.format(&#x27;%s: %s\\n%s\\npid: %s\\n&#x27;, err.name, err.message, err.stack, process.pid);\n        } else {\n            args[0] = util.format(customMsg, args[0]);\n        }\n\n        &#x2F;&#x2F; 这个是必须的，否则日志文件不会写入\n        super.log(level, args, meta);\n    }\n\n    &#x2F;**\n     * 自定义消息格式\n     * 可以根据自己的业务需求自行定义\n     * @param { String } level\n     *&#x2F;\n    messageFormat({\n        level\n    }) {\n        const { ctx } = this;\n        const params = JSON.stringify(Object.assign({}, ctx.request.query, ctx.body));\n\n        return [\n            moment().format(&#x27;YYYY&#x2F;MM&#x2F;DD HH:mm:ss&#x27;),\n            ctx.request.get(&#x27;traceId&#x27;),\n            utils.serviceIPAddress,\n            utils.clientIPAddress(ctx.req),\n            level,\n        ].join(utils.loggerDelimiter) + utils.loggerDelimiter;\n    }\n}\n\nmodule.exports = AppTransport;\n</code></pre><ul>\n<li><strong>工具</strong></li>\n</ul>\n<blockquote>\n<p>egg-logger-custom/lib/utils.js</p>\n</blockquote>\n<pre class="prettyprint language-js"><code>const interfaces = require(&#x27;os&#x27;).networkInterfaces();\n\nmodule.exports = {\n\n    &#x2F;**\n     * 日志分隔符\n     *&#x2F;\n    loggerDelimiter: &#x27;[]&#x27;,\n\n    &#x2F;**\n     * 获取当前服务器IP\n     *&#x2F;\n    serviceIPAddress: (() =&gt; {\n        for (const devName in interfaces) {\n            const iface = interfaces[devName];\n\n            for (let i = 0; i &lt; iface.length; i++) {\n                const alias = iface[i];\n\n                if (alias.family === &#x27;IPv4&#x27; &amp;&amp; alias.address !== &#x27;127.0.0.1&#x27; &amp;&amp; !alias.internal) {\n                    return alias.address;\n                }\n            }\n        }\n    })(),\n\n    &#x2F;**\n     * 获取当前请求客户端IP\n     * 不安全的写法\n     *&#x2F;\n    clientIPAddress: req =&gt; {\n        const address = req.headers[&#x27;x-forwarded-for&#x27;] || &#x2F;&#x2F; 判断是否有反向代理 IP\n        req.connection.remoteAddress || &#x2F;&#x2F; 判断 connection 的远程 IP\n        req.socket.remoteAddress || &#x2F;&#x2F; 判断后端的 socket 的 IP\n        req.connection.socket.remoteAddress;\n\n        return address.replace(&#x2F;::ffff:&#x2F;ig, &#x27;&#x27;);\n    },\n\n    clientIPAddress: ctx =&gt; {    \n        return ctx.ip;\n    },\n}\n</code></pre><p><strong>注意</strong>：以上获取当前请求客户端IP的方式，如果你需要对用户的 IP 做限流、防刷限制，请不要使用如上方式，参见 <a href="https://www.yuque.com/egg/nodejs/coopsc">科普文：如何伪造和获取用户真实 IP ？</a>，在 Egg.js 里你也可以通过 ctx.ip 来获取，参考 <a href="https://eggjs.org/zh-cn/tutorials/proxy.html">前置代理模式</a>。</p>\n<ul>\n<li><strong>初始化 Logger</strong></li>\n</ul>\n<pre class="prettyprint"><code>egg-logger-custom&#x2F;app.js\n</code></pre><pre class="prettyprint language-js"><code>const Logger = require(&#x27;egg-logger&#x27;).Logger;\nconst ConsoleTransport = require(&#x27;egg-logger&#x27;).ConsoleTransport;\nconst AppTransport = require(&#x27;.&#x2F;app&#x2F;logger&#x27;);\n\nmodule.exports = (ctx, options) =&gt; {\n    const logger = new Logger();\n\n    logger.set(&#x27;file&#x27;, new AppTransport({\n        level: options.fileLoggerLevel || &#x27;INFO&#x27;,\n        file: &#96;&#x2F;var&#x2F;logs&#x2F;${options.appName}&#x2F;bizLog&#x2F;${options.appName}.log&#96;,\n    }, ctx));\n\n    logger.set(&#x27;console&#x27;, new ConsoleTransport({\n        level: options.consoleLevel || &#x27;INFO&#x27;,\n    }));\n\n    return logger;\n}\n</code></pre><p>以上对于日志定制格式开发已经好了，如果你有实际业务需要可以根据自己团队的需求，封装为团队内部的一个 npm 中间件来使用。</p>\n<h2>项目扩展</h2>\n<p>自定义日志中间件封装好之后，在实际项目应用中我们还需要一步操作，Egg 提供了 <a href="https://eggjs.org/zh-cn/basics/extend.html">框架扩展</a> 功能，包含五项：Application、Context、Request、Response、Helper，可以对这几项进行自定义扩展，对于日志因为每次日志记录我们需要记录当前请求携带的 traceId 做一个链路追踪，需要用到 Context（是 Koa 的请求上下文） 扩展项。</p>\n<p>新建 <code>app/extend/context.js</code> 文件</p>\n<pre class="prettyprint language-js"><code>const AppLogger = require(&#x27;egg-logger-custom&#x27;); &#x2F;&#x2F; 上面定义的中间件\n\nmodule.exports = {\n    get logger() { &#x2F;&#x2F; 名字自定义 也可以是 customLogger\n        return AppLogger(this, {\n            appName: &#x27;test&#x27;, &#x2F;&#x2F; 项目名称\n            consoleLevel: &#x27;DEBUG&#x27;, &#x2F;&#x2F; 终端日志级别\n            fileLoggerLevel: &#x27;DEBUG&#x27;, &#x2F;&#x2F; 文件日志级别\n        });\n    }\n}\n</code></pre><p><strong>建议</strong>：对于日志级别，可以采用配置中心如 Consul 进行配置，上线时日志级别设置为 INFO，当需要生产问题排查时，可以动态开启 DEBUG 模式。关于 Consul 可以关注我之前写的 <a href="https://www.nodejs.red/#/microservice/consul">服务注册发现 Consul 系列</a></p>\n<h2>项目应用</h2>\n<p>错误日志记录，直接会将错误日志完整堆栈信息记录下来，并且输出到 errorLog 中，为了保证异常可追踪，必须保证所有抛出的异常都是 Error 类型，因为只有 Error 类型才会带上堆栈信息，定位到问题。</p>\n<pre class="prettyprint language-js"><code>const Controller = require(&#x27;egg&#x27;).Controller;\n\nclass ExampleController extends Controller {\n    async list() {\n        const { ctx } = this;\n\n        ctx.logger.error(new Error(&#x27;程序异常！&#x27;));\n\n        ctx.logger.debug(&#x27;测试&#x27;);\n\n        ctx.logger.info(&#x27;测试&#x27;);\n    }\n}\n</code></pre><p>最终日志打印格式如下所示：</p>\n<pre class="prettyprint"><code>2019&#x2F;05&#x2F;30 01:50:21[]d373c38a-344b-4b36-b931-1e8981aef14f[]192.168.1.20[]221.69.245.153[]INFO[]测试\n</code></pre><h2>contextFormatter自定义日志格式</h2>\n<p>Egg-Logger 最新版本支持通过 contextFormatter 函数自定义日志格式，参见之前 <a href="https://github.com/eggjs/egg-logger/pull/51">PR：support contextFormatter #51</a></p>\n<p>应用也很简单，通过配置 contextFormatter 函数即可，以下是简单的应用</p>\n<pre class="prettyprint language-js"><code>config.logger = {\n    contextFormatter: function(meta) {\n        console.log(meta);\n        return [\n            meta.date,\n            meta.message\n        ].join(&#x27;[]&#x27;)\n    },\n    ...\n};\n</code></pre><p>同样的在你的业务里对于需要打印日志的地方，和之前一样</p>\n<pre class="prettyprint language-js"><code>ctx.logger.info(&#x27;这是一个测试数据&#x27;);\n</code></pre><p>输出结果如下所示：</p>\n<pre class="prettyprint"><code>2019-06-04 12:20:10,421[]这是一个测试数据\n</code></pre><h2>日志切割</h2>\n<p>框架提供了 <a href="https://github.com/eggjs/egg-logrotator">egg-logrotator</a> 中间件，默认切割为按天切割，其它方式可参考官网自行配置。</p>\n<ul>\n<li><strong>框架默认日志路径</strong></li>\n</ul>\n<blockquote>\n<p>egg-logger 模块 lib/egg/config/config.default.js</p>\n</blockquote>\n<pre class="prettyprint language-js"><code>config.logger = {\n    dir: path.join(appInfo.root, &#x27;logs&#x27;, appInfo.name),\n    ...\n};\n</code></pre><ul>\n<li><strong>自定义日志目录</strong></li>\n</ul>\n<p>很简单按照我们的需求在项目配置文件重新定义 logger 的 dir 路径</p>\n<pre class="prettyprint language-js"><code>config.logger = {\n    dir: &#x2F;var&#x2F;logs&#x2F;test&#x2F;bizLog&#x2F;\n}\n</code></pre><p>这样是否就可以呢？按照我们上面自定义的日志文件名格式（<code>${projectName}-yyyyMMdd.log</code>），貌似是不行的，在日志分割过程中默认的文件名格式为 <code>.log.YYYY-MM-DD</code>，参考源码</p>\n<blockquote>\n<p><a href="https://github.com/eggjs/egg-logrotator/blob/master/app/lib/day_rotator.js">https://github.com/eggjs/egg-logrotator/blob/master/app/lib/day_rotator.js</a></p>\n</blockquote>\n<pre class="prettyprint language-js"><code> _setFile(srcPath, files) {\n    &#x2F;&#x2F; don&#x27;t rotate logPath in filesRotateBySize\n    if (this.filesRotateBySize.indexOf(srcPath) &gt; -1) {\n      return;\n    }\n\n    &#x2F;&#x2F; don&#x27;t rotate logPath in filesRotateByHour\n    if (this.filesRotateByHour.indexOf(srcPath) &gt; -1) {\n      return;\n    }\n\n    if (!files.has(srcPath)) {\n      &#x2F;&#x2F; allow 2 minutes deviation\n      const targetPath = srcPath + moment()\n        .subtract(23, &#x27;hours&#x27;)\n        .subtract(58, &#x27;minutes&#x27;)\n        .format(&#x27;.YYYY-MM-DD&#x27;); &#x2F;&#x2F; 日志格式定义\n      debug(&#x27;set file %s =&gt; %s&#x27;, srcPath, targetPath);\n      files.set(srcPath, { srcPath, targetPath });\n    }\n }\n</code></pre><ul>\n<li><strong>日志分割扩展</strong></li>\n</ul>\n<p>中间件 <a href="https://github.com/eggjs/egg-logrotator">egg-logrotator</a> 预留了扩展接口，对于自定义的日志文件名，可以用框架提供的 app.LogRotator 做一个定制。</p>\n<blockquote>\n<p>app/schedule/custom.js</p>\n</blockquote>\n<pre class="prettyprint language-js"><code>const moment = require(&#x27;moment&#x27;);\n\nmodule.exports = app =&gt; {\n    const rotator = getRotator(app);\n\n    return {\n        schedule: {\n            type: &#x27;worker&#x27;, &#x2F;&#x2F; only one worker run this task\n            cron: &#x27;1 0 0 * * *&#x27;, &#x2F;&#x2F; run every day at 00:00\n        },\n        async task() {\n            await rotator.rotate();\n        }\n    };\n};\n\nfunction getRotator(app) {\n    class CustomRotator extends app.LogRotator {\n        async getRotateFiles() {\n            const files = new Map();\n            const srcPath = &#96;&#x2F;var&#x2F;logs&#x2F;test&#x2F;bizLog&#x2F;test.log&#96;;\n            const targetPath = &#96;&#x2F;var&#x2F;logs&#x2F;test&#x2F;bizLog&#x2F;test-${moment().subtract(1, &#x27;days&#x27;).format(&#x27;YYYY-MM-DD&#x27;)}.log&#96;;\n            files.set(srcPath, { srcPath, targetPath });\n            return files;\n        }\n    }\n\n    return new CustomRotator({ app });\n}\n</code></pre><p>经过分割之后文件展示如下：</p>\n<pre class="prettyprint language-bash"><code>$ ls -lh &#x2F;var&#x2F;logs&#x2F;test&#x2F;bizLog&#x2F;\ntotal 188K\n-rw-r--r-- 1 root root 135K Jun  1 11:00 test-2019-06-01.log\n-rw-r--r-- 1 root root  912 Jun  2 09:44 test-2019-06-02.log\n-rw-r--r-- 1 root root  40K Jun  3 11:49 test.log\n</code></pre><p><strong>扩展</strong>：基于以上日志格式，可以采用 ELK 做日志搜集、分析、检索。</p>\n<h2>阅读推荐</h2>\n<ul>\n<li>侧重于Nodejs服务端技术栈：<a href="https://www.nodejs.red">https://www.nodejs.red</a></li>\n<li>公众号：Nodejs技术栈</li>\n</ul>\n</div>', 'title': '基于Egg框架的日志链路追踪实践分享', 'last_reply_at': '2019-06-04T09:17:52.622Z', 'good': false, 'top': false, 'reply_count': 8, 'visit_count': 323, 'create_at': '2019-06-03T14:06:35.182Z', 'author': { 'loginname': 'Q-Angelo', 'avatar_url': 'https://avatars0.githubusercontent.com/u/17956058?v=4&s=120' } }, { 'id': '5ce6646a52ccb64168ba6dc2', 'author_id': '58f837a3bbaf2f3f569be082', 'tab': 'share', 'content': '<div class="markdown-text"><blockquote>\n<p>作者：鬼柒\n原文：<a href="https://www.douban.com/note/719582021/">https://www.douban.com/note/719582021/</a>\n互联网时光机备份：<a href="https://archive.fo/6y5zJ">https://archive.fo/6y5zJ</a></p>\n</blockquote>\n<p>996 ICU的项目来龙去脉相信很多人都知道了，这里不再复述。想了解清晰一点的话可以看看知乎这个答案  <a href="https://www.zhihu.com/question/317722302/answer/635760914">996 ICU 项目的来龙去脉</a></p>\n<p>我现在正在做信息公开的申请，跟诉讼事宜，相关信息可以查看这篇稿子。 <a href="https://github.com/CPdogson/996action/blob/master/Press-releases/chengdususong.md">996action行政诉讼第一案</a></p>\n<p>我自己已经没有在996了，而且也算是中高级职位，做好工期预估工作，推掉一些不合理需求，整个团队能够按照正常的工作时间进行，工作气氛不错，也可以利用一些业余时间学习，继续增进自己的能力，不过还是会有一些紧急情况，安排少量的加班不可避免。</p>\n<p>我开始关注加班问题，大概也是4-5年前了，当时某公司出现过劳猝死的事件，我发了一些拙见，也有几百个赞， <a href="https://www.zhihu.com/question/38567964/answer/77045960">关于加班的一些个人观点</a></p>\n<p>当然更早一点的时候我就注意到所在的行业气氛，对加班居然已经形成了一种叫”加班文化“的流氓现象，所以一直都有在思考一些个人的出路，我自己也经历过1-2个月无休，每晚加班到凌晨的情况，到了极限的时候，脑袋里一团浆糊的感觉也越来越重。</p>\n<p>我深知其危害，也绝不会放弃思索解决之道。</p>\n<p>4月的时候爆发了这个事件，当时也是恰巧有好几个互联网公司公开半公开的说了996制度，厚颜无耻。</p>\n<p>IT从业人士积压了很多怨气，所以宣泄口一开，居然也形成了一股力量，开始开枝散叶，做了很多事情，其中狗崽开的子项目996action 996law 我个人觉得是一条既合法又严谨的方案，但是这里面要参与者实名去跟行政部门打交道，中国5千年的奴隶思维，就算到了近代，也还是有点怕，我也有点方。但是这件事必须去做，必须有人去做才行，我也想过在后面吆喝，鼓励其他人去做，然后我提提建议就行了，直到我意识到一个情况，大家都是这么想的。</p>\n<p>必须有人迈出第一步，我重新把所有资料认真研究了一遍，也跟狗崽细聊了一段时间。</p>\n<p>所以我为什么要做这些事情，信息公开申请，复议，诉讼等，因为我爱己，就绝不会继续折损自己的生命。然后我爱后代，既然爱护后代，就一定不能让TA们生活在一个坏时代，然后我热爱自己的职业，那么爱屋及乌，我也同情与我有相同遭遇的人们，如果我们真的爱我们的国与家，真正发自内心的爱，就是不能忍心让劳动者继续在泥潭里深陷，不能忍心所以要有所行动，能发一点光的，发点光，能发一点热的，发点热。就算到了最后，可能一无所获，但是这条路我们走过了，不管成功了或是失败了，以后的人们便可以看到种种的经验，有了前车之鉴，去探索更好的路，那么我们的努力也就绝不会枉费。</p>\n<p>而且狗崽还有其他朋友努力整理了很多资料，写了很多方案，稿件等，这件事如果没有人愿意参与，那么这些努力就白费了，我实在无法坐视不管，要多么多么难得，才会有人愿意在这件事上付出努力，我实在是没办法眼看这些非常善意的努力无法推进。</p>\n<p>最近诉讼还在等待立案，资料已经送达法院，后续会发生什么事情，我也不知道，咱也不敢问。</p>\n<p>但是很多开发者给我们发了很多鼓励的话，”加油！“” 注意安全！“” 祝马到成功 “等等</p>\n<p>我也有点紧张，行政部门的大佬打电话来问：”你为什么要跨市申请信息公开？你都不在这边工作“ ，我如实说，寄了好几个城市的申请，做汇总之后想对比一下不同城市的用工情况，对我个人而言，我以后选择其他工作也会作为参考，所以这件事于己于人，都是有利的。毕竟没有多少人愿意相信，我做这个事是为了一些毫不相关的陌生人。但是我在这里可以畅所欲言，我就是为了毫不相干的陌生人。</p>\n<p><strong>陌生人，我爱你</strong></p>\n</div>', 'title': '为什么“我”要做这些事 ，996 ICU是不是真的无解？', 'last_reply_at': '2019-06-04T08:28:11.458Z', 'good': false, 'top': false, 'reply_count': 2, 'visit_count': 918, 'create_at': '2019-05-23T09:14:18.895Z', 'author': { 'loginname': 'shuiRong', 'avatar_url': 'https://avatars1.githubusercontent.com/u/16076993?v=4&s=120' } }, { 'id': '5c1c425c76c4964062a1c0ef', 'author_id': '5c1c411f76c4964062a1c0e3', 'tab': 'share', 'content': '<div class="markdown-text"><p>推荐一个前端导航网站，记录了各种关于前端的网址，可以直接在对应社区查找问题。\n喜欢的话赶快收藏一波吧 ^^\n网站地址： <strong><a href="https://www.frontendjs.com/">https://www.frontendjs.com/</a></strong></p>\n<p><img src="//static.cnodejs.org/Fk1zwq8EO9Ugzovv-D1T5-GUnuIy" alt="3898986698-5c05daee066b9_articlex.png"></p>\n</div>', 'title': '前端导航网址分享，觉得有帮助的可以收藏下', 'last_reply_at': '2019-06-04T07:50:50.052Z', 'good': false, 'top': false, 'reply_count': 20, 'visit_count': 2659, 'create_at': '2018-12-21T01:31:08.779Z', 'author': { 'loginname': 'bestvist', 'avatar_url': 'https://avatars2.githubusercontent.com/u/22828569?v=4&s=120' } }, { 'id': '5b599f682860af042a2178e9', 'author_id': '57c8e6f86f7069ce262d0504', 'tab': 'ask', 'content': '<div class="markdown-text"><p>大概是这样的，我有个需求，需要向某个api 不断的请求，而且数量不小，有点像压力测试吧</p>\n<pre class="prettyprint"><code>const fetch = require(&#x27;node-fetch&#x27;);\nconst funs = async () =&gt; {\n  const now = Date.now();\n  await fetch(&#x27;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#x27;);\n console.log(i, &#96;start:${now}&#96;, &#96;end:${Date.now()}&#96;, &#96;use:${Date.now() - now}&#96;);\n};\n</code></pre><p>在我的机器上跑，发现  同时跑 10、100、1000得到的结果时间相差太多</p>\n<pre class="prettyprint"><code> for (let i = 0; i &lt; 10; i += 1) {\n   funs(i);\n }\n &#x2F;&#x2F; funs log的时间大概是 80-100ms 递增\n \n for (let i = 0; i &lt; 100; i += 1) {\n   funs(i);\n }\n &#x2F;&#x2F; funs log的时间大概是 500-800ms 递增\n \n for (let i = 0; i &lt; 1000; i += 1) {\n   funs(i);\n }\n &#x2F;&#x2F; funs log的时间大概是 1000-5000ms 递增\n</code></pre><h6>部分评论的尝试</h6>\n<pre class="prettyprint"><code>&#x2F;&#x2F;01，尝试设置maxSockets \nhttps.globalAgent.maxSockets = 1000;\nhttps.globalAgent.maxFreeSockets = 1000;\n</code></pre><pre class="prettyprint"><code>&#x2F;&#x2F;02，用原生https尝试设置new Agent  \nconst https = require(&#x27;https&#x27;);\nconst $get = (i) =&gt; {\n  const now = Date.now();\n  const agent = new https.Agent();\n  const options = {\n    hostname: &#x27;www.baidu.com&#x27;,\n    port: 443,\n    method: &#x27;GET&#x27;,\n    agent: false, &#x2F;&#x2F; agent\n  };\n  https.get(options, () =&gt; {\n    console.log(i, &#96;start:${now}&#96;, &#96;end:${Date.now()}&#96;, &#96;use:${Date.now() - now}&#96;);\n  }).on(&#x27;error&#x27;, () =&gt; {\n    console.log(i, &#96;start:${now}&#96;, &#96;end:${Date.now()}&#96;, &#96;use:${Date.now() - now}&#96;);\n  });\n};\n\nfor (let i = 0; i &lt; 1000; i += 1) {\n  $get(i);\n}\n&#x2F;&#x2F;结果还是没变化\n</code></pre><h5>不明白造成请求的时间变长的具体原因是啥？</h5>\n<p>瞎猜1 node有类似浏览器一样有请求数限制？</p>\n<p>瞎猜2 TCP链接数限制？</p>\n<h5>希望能解决： 10000并发以内不会出现大幅度延迟</h5>\n<h4>有没有大佬帮忙解惑？</h4>\n</div>', 'title': 'node发出的请求数多了，整体响应变慢，不清处影响的因素是什么，求解惑。', 'last_reply_at': '2019-06-04T05:09:54.566Z', 'good': false, 'top': false, 'reply_count': 36, 'visit_count': 3406, 'create_at': '2018-07-26T10:16:08.459Z', 'author': { 'loginname': 'THROFHR', 'avatar_url': 'https://avatars1.githubusercontent.com/u/13469743?v=4&s=120' } }, { 'id': '5cf5344d1fe902120f31bcce', 'author_id': '56daaf5dc0fa23473d005feb', 'tab': 'share', 'content': '<div class="markdown-text"><p>吐槽一波，亚马逊云的数据库DynamoDB真心难用</p>\n<p>分享一下经过改良的DynamoDB导出CSV文件教程：<a href="https://github.com/zhulinwei/dynamodb-to-csv">dynamodb-to-csv</a></p>\n</div>', 'title': 'AWS DynamoDB数据导入CSV文件', 'last_reply_at': '2019-06-04T05:00:20.047Z', 'good': false, 'top': false, 'reply_count': 4, 'visit_count': 228, 'create_at': '2019-06-03T14:53:01.999Z', 'author': { 'loginname': 'zhulinwei', 'avatar_url': 'https://avatars2.githubusercontent.com/u/17670262?v=4&s=120' } }, { 'id': '5cf4b1f295fcc914aa2658d0', 'author_id': '53b25565399ed9e07d1e8793', 'tab': 'ask', 'content': '<div class="markdown-text"><p>nodejs-websocket 创建服务</p>\n<pre class="prettyprint language-js"><code>var ws = require(&quot;nodejs-websocket&quot;)\n \n&#x2F;&#x2F; Scream server example: &quot;hi&quot; -&gt; &quot;HI!!!&quot;\nvar server = ws.createServer(function (conn) {\n    console.log(&quot;New connection&quot;)\n    conn.on(&quot;text&quot;, function (str) {\n        console.log(&quot;Received &quot;+str)\n        conn.sendText(str.toUpperCase()+&quot;!!!&quot;)\n    })\n    conn.on(&quot;close&quot;, function (code, reason) {\n        console.log(&quot;Connection closed&quot;)\n    })\n}).listen(8001)\n</code></pre><p>http 创建服务</p>\n<pre class="prettyprint language-js"><code>const http = require(&quot;http&quot;);\nconst fs = require(&quot;fs&quot;);\n\nhttp\n  .createServer(function(req, res) {\n    res.writeHead(200, { &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; });\n    var stream = fs.createReadStream(&quot;.&#x2F;index.html&quot;);\n    stream.on(&quot;open&quot;, function(fd) {\n      &#x2F;&#x2F; console.log(&#x27;开始读取文件&#x27;);\n    });\n    stream.on(&quot;data&quot;, function(data) {\n      &#x2F;&#x2F; console.log(&#x27;读取到数据：&#x27;);\n      &#x2F;&#x2F; console.log(data.toString());\n      res.write(data);\n    });\n    stream.on(&quot;end&quot;, function() {\n      &#x2F;&#x2F; console.log(&#x27;文件已全部读取完毕&#x27;);\n      res.end();\n    });\n    stream.on(&quot;close&quot;, function() {\n      &#x2F;&#x2F; console.log(&#x27;文件被关闭&#x27;);\n    });\n    stream.on(&quot;error&quot;, function(err) {\n      &#x2F;&#x2F; console.log(&#x27;读取文件失败&#x27;);\n      res.writeHead(500, { &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; });\n      res.write(&quot;500 error&quot;);\n    });\n  })\n  .listen(3000);\n</code></pre><p>有办法把这两个端口共用吗？</p>\n</div>', 'title': '怎么让 nodejs-websocket 启动的ws服务与http启动的http服务共用一个端口呢？', 'last_reply_at': '2019-06-04T03:49:17.101Z', 'good': false, 'top': false, 'reply_count': 1, 'visit_count': 262, 'create_at': '2019-06-03T05:36:50.632Z', 'author': { 'loginname': 'tomoya92', 'avatar_url': 'https://avatars2.githubusercontent.com/u/6915570?v=4&s=120' } }, { 'id': '5cf5e2581fe902120f31be6e', 'author_id': '584d7dce4c17b38d35436595', 'tab': 'ask', 'content': '<div class="markdown-text"><p>这里使用的是createBrowserHistory({forceRefresh:true}强制刷新的做法，除了这个还有其他方法吗，用的是React-routerV4</p>\n<pre class="prettyprint language-bash"><code>&#x2F;&#x2F; history\nimport { createBrowserHistory } from &quot;history&quot;;\nexport default createBrowserHistory({forceRefresh:true}); \n\nimport axios from &quot;axios&quot;; \nimport {fakeAuth} from &#x27;..&#x2F;util&#x2F;fakeAuth&#x27;;\nimport {message as Message} from &#x27;antd&#x27;;\nimport {timeout,baseURL} from &quot;.&#x2F;config.js&quot;;\nimport history from &#x27;.&#x2F;history&#x27;;\naxios.defaults.timeout = timeout;\naxios.defaults.baseURL = baseURL;\naxios.interceptors.request.use(\n    config =&gt; {\n        if (fakeAuth.authenticate()) {\n            config.headers.Authorization = &#96;Bearer ${sessionStorage.getItem(&#x27;loginToken&#x27;)}&#96;;\n        }\n        return config;\n    },\n    error =&gt; {\n        return Promise.reject(error);\n    }\n);\naxios.interceptors.response.use(\n    response =&gt; {\n        return response;\n    },\n    error =&gt; {\n        if (error.response) {\n            switch (error.response.status) {\n                case 401:\n                    fakeAuth.signout();\n                    history.push(&#x27;&#x2F;login&#x27;);\n                    break;\n                default:\n            }\n            const message = error.response.data.message ?error.response.data.message :&quot;服务器异常&quot;;\n            Message.error(message);\n        }\n        return Promise.reject(error);\n    }\n);\n</code></pre></div>', 'title': 'React-router-dom如何在封装的axios中实现跳转', 'last_reply_at': '2019-06-04T03:15:36.990Z', 'good': false, 'top': false, 'reply_count': 0, 'visit_count': 139, 'create_at': '2019-06-04T03:15:36.990Z', 'author': { 'loginname': '1261407209LHH', 'avatar_url': 'https://avatars0.githubusercontent.com/u/15929863?v=4&s=120' } }, { 'id': '5b7ac9c7c52ad1482eb940bf', 'author_id': '5b52cbf1fb9e84ec69cc1ca2', 'tab': 'ask', 'content': '<div class="markdown-text"><p>Egg.js现在用的人多吗？那些公司在用有知道的吗？</p>\n<p>同上，老铁们出来吧。</p>\n</div>', 'title': 'Egg.js现在用的人多吗？那些公司在用有知道的吗？', 'last_reply_at': '2019-06-04T03:13:49.090Z', 'good': false, 'top': false, 'reply_count': 124, 'visit_count': 15164, 'create_at': '2018-08-20T14:01:43.981Z', 'author': { 'loginname': 'nodeper', 'avatar_url': 'https://avatars2.githubusercontent.com/u/41500847?v=4&s=120' } }, { 'id': '5cf5d65895fcc914aa265e53', 'author_id': '55c56e8a39273b9219336288', 'tab': 'share', 'content': '<div class="markdown-text"><blockquote>\n<p>最新原文: <a href="https://blog.t9t.io/tech-stack-of-open-source-jobs-2019-06-03/">https://blog.t9t.io/tech-stack-of-open-source-jobs-2019-06-03/</a>\n关键词: serverless + react server side rendering</p>\n</blockquote>\n<h2>产品简介</h2>\n<p><a href="https://github.com/t9tio/open-source-jobs">open-source-jobs</a> 是一个收集主要项目为开源, 并且提供工作机会的公司的网站. 一开始只是一个 github 上的 markdown 项目. 因为发表到 <a href="https://www.reddit.com/r/programming/comments/b44hm5/a_list_of_jobs_whose_major_responsibility_is/?utm_source=share&amp;utm_medium=web2x">reddit</a> 上受到一些关注, 并且开源在近些年的蓬勃发展. 我觉得这个细分的找工作工具可能有一定价值, 于是把这个 markdown 做成了一个网站形式方便使用. 主要的两部分功能是用户通过 github 注册我可以拿到邮箱, 以及工作 /组织的暂时和筛选.</p>\n<h2>用到的工具, 技术以及我为什么这么选择</h2>\n<h3>Serverless</h3>\n<p>技术选择里面最重要的可能就是选择了以 serverless 的方式开发.</p>\n<p>Serverless 这个名字其实取得不是那么好, 容易让人以为开发网站不再需要服务器, 其实它真正的意思不是没有 server, 而是 server 由云平台帮你管理了, 根据需求自动伸缩服务器资源.</p>\n<p>Serverless 目前可能还有各种问题, 比如代码包尺寸限制, 语言限制等. 但它的好处也是显而易见的, 你不用管理服务器了!!</p>\n<p>做过几个失败的网站的同学应该有所经验. 一个纯前端的项目, 基本不会死, 因为你不用维护它, 还有各种免费稳定的托管静态网站的服务, 它总能正常工作.</p>\n<p>但对于带服务器的网站就不一样了, 很多时候网站失败的原因都是因为有一天服务器挂了, 你觉得这个东西反正没什么人用, 我还要花时间去管理服务器, 为这个服务器付钱. 挂了就挂了吧. 但我们也知道, 一些网站 /应用想要成功, 时间也是一个关键因素. 尤其对于小众网站. 刚做出来, 分享到各个地方, 因为需求比较小众, 一开始收到的关注可能不是那么多, 很难通过一个很成功发布获得很多用户. 主要还是靠有这种需求的人通过搜索引擎找到你这个工具. 所以用户量需要时间慢慢增加. 网站需要你在用户量比较少的情况下长期维护. 如果没有 serverless, 在这漫长而没有太多回报的维护生涯中, 你很有可能就放弃了.</p>\n<p>Serverless 让写后端变得更像前端了一些, 你只负责写为用户提供价值的逻辑, 维护服务器这种脏活就不用管了. 增加了这种应用的成活时长, 使之更有可能成功.</p>\n<p><a href="https://github.com/t9tio/open-source-jobs">open-source-jobs</a> 在我看来就是属于这一类的应用. 比较小众, 现在可能没有那么大需求, 但需求在慢慢增长. 是一个需要慢慢成长的小众产品.</p>\n<h4>Serverless 开发用到的工具</h4>\n<ul>\n<li>Server: <a href="https://aws.amazon.com/lambda/">AWS lambda</a></li>\n<li>Serverless Database: <a href="https://aws.amazon.com/dynamodb/">AWS dynamodb</a></li>\n<li>Easy Deployment: <a href="https://github.com/apex/up">apex up</a>\n<ul>\n<li>这里的部署包括: 子域名自动注册; HTTPS; 以及部署服务端最新代码</li>\n</ul>\n</li>\n</ul>\n<h3>前端模块化开发: React</h3>\n<p>React 可能不用多做介绍了, 是现在前端圈子里最火的框架. 让你可以模块化开发前端页面.</p>\n<ul>\n<li>Frontend Components: <a href="https://reactjs.org/">React.js</a></li>\n</ul>\n<h3>Server Side Rendering(SSR)</h3>\n<p>open-source-jobs 是一个内容站, 所以对搜索引擎友好是很重要的一点, 目前 React 圈这一点做的最好的应该就是 next.js 了</p>\n<ul>\n<li>Server Side Rendering for SEO: <a href="https://github.com/zeit/next.js/">next.js</a></li>\n</ul>\n<h2>最后附上项目链接和源码地址</h2>\n<ul>\n<li><a href="https://oo.t9t.io">网站地址</a></li>\n<li><a href="https://github.com/t9tio/open-source-jobs">Github 源码</a></li>\n<li><a href="https://github.com/t9tio/open-source-jobs#folder-structure">代码结构</a></li>\n</ul>\n</div>', 'title': '我最近一个网站的技术选择和源码分享', 'last_reply_at': '2019-06-04T02:24:24.898Z', 'good': false, 'top': false, 'reply_count': 0, 'visit_count': 208, 'create_at': '2019-06-04T02:24:24.898Z', 'author': { 'loginname': 'timqian', 'avatar_url': 'https://avatars3.githubusercontent.com/u/5512552?v=4&s=120' } }, { 'id': '5cf5bb9695fcc914aa265d4a', 'author_id': '551cf03133e515e676406561', 'tab': 'ask', 'content': '<div class="markdown-text"><p>例如使用axios连续发送200个请求给另外一个http接口。发现node会一口气把这200个请求全部发完再执行回调，当ab测试量加大时，会导致请求的回调要等好几秒才执行。大大拖慢了一个请求的时长。请问http.request或axios如何不让请求本身阻塞回调，无解吗</p>\n</div>', 'title': 'Node并发发送http请求会占用io回调的时间？', 'last_reply_at': '2019-06-04T02:13:04.945Z', 'good': false, 'top': false, 'reply_count': 4, 'visit_count': 274, 'create_at': '2019-06-04T00:30:14.313Z', 'author': { 'loginname': 'cuiyongjian', 'avatar_url': 'https://avatars0.githubusercontent.com/u/3937196?v=4&s=120' } }, { 'id': '5b8de66137b3005a0b0e6b3f', 'author_id': '5b8de41bbf116a8c0e42579f', 'tab': 'share', 'content': '<div class="markdown-text"><p>Egg.js入门视频教程主要讲了Egg的环境搭建   egg的控制器      egg服务  egg中间件   egg路由 egg扩展   egg模板引擎  egg cookie   egg session</p>\n<p><strong>Eggjs 视频教程百度网盘分享接</strong>： <a href="https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w">https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w</a></p>\n<p><strong>或者此连接Egg.js视频教程10讲入门链接</strong>： <a href="https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg">https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg</a>  <strong>密码</strong>：4b6i</p>\n<p><strong>来源</strong>  <a href="https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf">https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf</a></p>\n<p>希望老铁门能喜欢\n<img src="//static.cnodejs.org/FoPZNWCMpHqWFAb2QDns-UhIMX-3" alt="egg01.png"></p>\n<p><img src="//static.cnodejs.org/Fu4_-OevpWiKHFqeEGBOW53MCdnE" alt="egg02.png"></p>\n<p><img src="//static.cnodejs.org/FtOEkaeRTUNyuWE2mhvazrxPc6cd" alt="egg03.png"></p>\n<p><img src="//static.cnodejs.org/FtJsuDe3kbcNYWWcJyfxuE08wVs5" alt="egg05.png"></p>\n<p><img src="//static.cnodejs.org/Fp8erhbPkGZrsYFsd-gxn2z4Gssb" alt="222.png"></p>\n<p><img src="//static.cnodejs.org/FhCAuCKVwbQnTCJWtkGKv6ZR8toN" alt="06.png"></p>\n</div>', 'title': 'Egg.js视频教程-Eggjs入门视频教程网盘免费分享-10讲入门基础希望老铁门能喜欢', 'last_reply_at': '2019-06-04T01:58:00.620Z', 'good': false, 'top': false, 'reply_count': 96, 'visit_count': 13836, 'create_at': '2018-09-04T01:56:49.179Z', 'author': { 'loginname': 'zlyuanteng', 'avatar_url': 'https://avatars0.githubusercontent.com/u/42952042?v=4&s=120' } }, { 'id': '5ce6a9d54036f24194cf5f1e', 'author_id': '5bc6779d37a6965f5905229a', 'tab': 'ask', 'content': '<div class="markdown-text"><p>請問node.js有像java 一樣的流程引擎嗎？例如jBPM、Activiti，謝謝前輩們~</p>\n</div>', 'title': '請問node.js有像java 一樣的流程引擎嗎？例如jBPM、Activiti，謝謝前輩們~', 'last_reply_at': '2019-06-04T00:39:40.024Z', 'good': false, 'top': false, 'reply_count': 11, 'visit_count': 905, 'create_at': '2019-05-23T14:10:29.327Z', 'author': { 'loginname': 'Solomonqoo', 'avatar_url': 'https://avatars3.githubusercontent.com/u/44214486?v=4&s=120' } }, { 'id': '5b18a28557137f22415c49e9', 'author_id': '55d120f3b25bd72150842d85', 'tab': 'share', 'content': '<div class="markdown-text"><h1>前端进阶之困</h1>\n<p>最近看了不少文章和帖子， 如文：</p>\n<ul>\n<li><a href="https://juejin.im/post/5b124fdd5188257d6c0465da?utm_source=gold_browser_extension">前端的焦虑，你想过30岁以后的前端路怎么走吗？</a></li>\n<li><a href="https://cnodejs.org/topic/5af047150a36e5312d6ecdf0">前端怎么一步步走向全栈呢？</a></li>\n<li><a href="https://cnodejs.org/topic/5b164efa29e6e510415b2803">移动端入门Node.js怎么学习?</a></li>\n<li><a href="https://cnodejs.org/topic/5a4cc04cebc575dc49b270d5">前端的未来走向在哪里？</a></li>\n<li><a href="https://cnodejs.org/topic/5ab1ebb5e7b166bb7b9eccaa">工作2年多的前端，现在迷茫了，如何更进一步的提升自己</a></li>\n</ul>\n<p>身边和朋友圈也不少做前端开发的同事朋友问如何发展和提升\n这里我向大家给一些建议</p>\n<h2>扎实基础</h2>\n<p>首先思考下手上的工作是否做得足够好了，近几年前端技术发展迅猛各种框架层出不穷，刚学会jquery还没用熟， angular 、vue 、react 已经满大街了。\ngulp 还没明白怎么回事、webpack 已开始遍地开花了。眼花缭乱的技术不知道从哪里开始好。\n如果你还被这些困扰的话，那请静下来思考一下，技术的发展总是有规律的，学习也是有规律可循的，我的建议是，把共性和必要的技能先稳固下来，既不浪费时间，又能提高效率，如果这块还么稳固好、框架什么少看几种吧，先有一样可用的就好。\n对于加强基础一个可行的方案是，从自己上手的工作开始、除了专注现学现用工作需要的框架技术外加强基础的学习，如：</p>\n<ul>\n<li>基本的逻辑（与、或、非）</li>\n<li>运算操作（加减乘除 Math 下的各种函数）</li>\n<li>字符串处理 （什么大小写、编码、裁剪什么的）</li>\n<li>时间处理 （日期的加减、对比、格式转换等）</li>\n<li>数组、集合对象处理\n可以了解学习一些基础库 如: <a href="https://github.com/lodash/lodash">lodash</a>、<a href="https://github.com/moment/moment">moment</a> 等、若时间有限可以看看示例有个印象回头可以查找，当然最好的方式是实践练习。</li>\n</ul>\n<h2>发展全栈的正确姿势</h2>\n<p>Javascript 生态链对于全栈有一些优势，但全栈不是贴金的标签，如果技能不够硬，必然落得个 <strong>前端不强，后端不行</strong> 的尴尬局面。</p>\n<h3>那对于前端是不是不该发展后端呢？</h3>\n<p>回答当然是否定的，前端<em>有目的、有计划的发展后端技能</em>，对于系统全局观、工作协作能力提升是非常有帮助的，<strong>另外切实让老板愿意为你加工资是非常可能的</strong>。</p>\n<h3>那要如何才能是有目的、有计划的发展后端技能呢？</h3>\n<p>首先认清后端技能出发点和关键点。</p>\n<ul>\n<li>出发点: 是主动权和话语权（可能某个后端老是鄙视你，你要的东西，说这个没办法，那个不应该，造成了你工作很被动，效率不高，出错了可能还先找你）。</li>\n<li>关键点: 前后端接口 （如果你能清晰、标准、明确你要的接口，那么一些都会明朗起来）。\n所以我认为前端切入后端应该从接口开始。</li>\n</ul>\n<h3>从标准接口开始，什么样的接口才是标准的呢？</h3>\n<p><a href="https://swagger.io/resources/open-api/">OpenAPI  Specification</a>\n这里我为大家推荐 Swagger 标准接口 (目前有两个标准 OAS 2.0 和 OAS 3.0)\nSwagger 致力于接口的标准化，并为此提供了一系列的工具，方便大家对进口进行标准化。</p>\n<h3>有什么好处呢</h3>\n<ul>\n<li>简化工作流程 (Streamline Your Workflow)。</li>\n<li>自由构建 (Restraint-Free Build)</li>\n<li>开放/全球化的支持 (Open &amp; Globally Supported)\n我的理解是增强系统的健壮性、降低沟通成本、提高写作效率，另外接口是系统的一种抽象可以更好的从宏观把握系统。</li>\n</ul>\n<h3>标准化的接口要如何实践</h3>\n<p>这里我安利下我的开源项目 <a href="https://github.com/vellengs/typerx">typerx</a>, typerx 是一个轻量注解式的全栈系统、你可以使用他快速的实践接口标准的全栈开发。</p>\n<ul>\n<li>创建接口前、我们仍旧还是要考虑接口模块的、模块化的设计能降低我们一次思考的复杂度。\n在 typerx 中我们分了 core 模块和 cms 模块。</li>\n<li>接口的创建从原型开始考虑、确定接口所需的模型 model, 这个模型我们称之为 DTO(data transform object) 也就是接口的输入输出数据对象。\n<a href="https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/dto">dto 的编写示例</a></li>\n<li>有了模型之后我们就可以确定需要哪些接口方法了，编写接口的时候先不着急考虑接口的实现，我们只要先提供模型（可以建立一个按模型提供的数据mock)确保必要的接口规格描述就好，\n<a href="https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/account.controller.ts">account 的接口定义</a>\n这里我们通过直接编写代码的方式来实现文档，这样方便我们高效、可维护的接口文档（当然先完成文档再来生成代码也是可以的，不过代码能表述的永远比文档能描述的多，所以应该是有一套能够自动生成api 文档的代码来维护比较合适，过去也曾从文档开始，但文档的错漏不方便验证、而且文档维护数据模型是很累的一个事情无法动态关联重构）。</li>\n<li>按要求完成了接口定义之后，你只要轻松运行</li>\n</ul>\n<pre class="prettyprint"><code>npm run build \n</code></pre><p>你就拥有标准的接口文档描述文件 swagger.json / swagger.yaml 了, 你可以使用 typerx 直接启动服务端预览接口 <a href="http://localhost:4700/docs">localhost:4700</a> 或者放到在线编辑器上预览 <a href="http://editor.swagger.io/">editor.swagger.io</a>;</p>\n<ul>\n<li>好了标准话的接口有了你可以保持这个接和后端的接口一致，这样就可以和后端愉快的协作了，当然如果你喜欢，直接使用 typerx 实现自己真实的后端。</li>\n</ul>\n<p>最后欢迎大家关注 <a href="https://github.com/vellengs/typerx">typerx</a> 一起讨论努力进阶。</p>\n</div>', 'title': '前端如何进阶全栈开发', 'last_reply_at': '2019-06-03T15:26:49.771Z', 'good': false, 'top': false, 'reply_count': 45, 'visit_count': 10631, 'create_at': '2018-06-07T03:12:05.854Z', 'author': { 'loginname': 'vellengs', 'avatar_url': 'https://avatars1.githubusercontent.com/u/5743338?v=4&s=120' } }, { 'id': '581ab06db37ee8fb33978a70', 'author_id': '51efacc6f4963ade0ee22267', 'tab': 'ask', 'content': '<div class="markdown-text"><p>情况： request.js 库请求接口， express.js 做 server ，实现了 curl <a href="http://localhost:8080/proxy-api">http://localhost:8080/proxy-api</a> 本地一个地址，在 router 里用 request.js 请求接口，统计了一下请求耗时，单个请求耗时很低，如下：</p>\n<pre class="prettyprint"><code>get http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 13 ms\n</code></pre><p>然后分别使用 webbench 和 ab 做并发测试，并发 500 ，发现接口有非常大的耗时。</p>\n<pre class="prettyprint"><code># 测试命令\nab -n 1000 -c 200 -r http:&#x2F;&#x2F;localhost:8080&#x2F;proxy-api\nwebbench -t 10 -c 500 http:&#x2F;&#x2F;localhost:8080&#x2F;proxy-api\n</code></pre><pre class="prettyprint"><code># 截取部分响应耗时：\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 2019 ms\ncost time:  2020\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 2062 ms\ncost time:  2062\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 2064 ms\ncost time:  2065\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 2063 ms\ncost time:  2063\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 2062 ms\ncost time:  2063\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 2063 ms\ncost time:  2063\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 2061 ms\ncost time:  2062\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 2063 ms\ncost time:  2064\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 2063 ms\n...\n...\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 1362 ms\ncost time:  1362\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 1361 ms\ncost time:  1362\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 1362 ms\ncost time:  1362\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 1362 ms\ncost time:  1362\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 1362 ms\ncost time:  1362\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 1363 ms\ncost time:  1363\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 1362 ms\ncost time:  1362\n...\n...\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 1006 ms\ncost time:  1006\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 627 ms\ncost time:  628\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 629 ms\ncost time:  629\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 628 ms\ncost time:  629\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 1403 ms\ncost time:  1403\nget http:&#x2F;&#x2F;ip:9190&#x2F;user&#x2F;getUserInfo 1402 ms\n</code></pre><p>请问哪位朋友有没有解决这类问题的经验？\n+++++++++++++++++\n2016-11-03 13:00:06 补充一下，简单测试问题的代码，序号输出是无序的，说明是异步，只不过越到后面越耗时：</p>\n<pre class="prettyprint"><code>const request = require(&#x27;request&#x27;).defaults({\n  pool: { maxSockets: 5000 }\n});\n\nconst c = 500;\nconst api = &#x27;替换为一个api&#x27;;\n\nfunction doGet(i) {\n  const start = Date.now();\n  const index = i;\n  request.get(api, () =&gt; {\n    const end = Date.now() - start;\n    console.log(&#96;${index}: ${end}ms&#96;);\n  });\n}\n\nfor (let i = 0; i &lt; c; i++) {\n  doGet(i);\n}\n</code></pre><p>执行结果：</p>\n<pre class="prettyprint"><code>3: 570ms\n1: 582ms\n5: 580ms\n7: 580ms\n9: 580ms\n11: 580ms\n2: 582ms\n0: 591ms\n4: 582ms\n6: 582ms\n12: 582ms\n10: 582ms\n8: 583ms\n14: 583ms\n13: 583ms\n16: 583ms\n17: 584ms\n20: 583ms\n22: 583ms\n24: 583ms\n26: 583ms\n28: 582ms\n30: 582ms\n...\n457: 2262ms\n467: 2263ms\n469: 2263ms\n237: 2283ms\n474: 2267ms\n471: 2267ms\n493: 2269ms\n475: 2272ms\n479: 2271ms\n477: 2272ms\n485: 2272ms\n483: 2273ms\n481: 2273ms\n487: 2273ms\n489: 2274ms\n495: 2273ms\n497: 2273ms\n499: 2274ms\n491: 4380ms\n</code></pre></div>', 'title': 'nodejs 请求接口在高并发下耗时很大，而单个请求非常快', 'last_reply_at': '2019-06-03T14:35:27.506Z', 'good': false, 'top': false, 'reply_count': 21, 'visit_count': 10910, 'create_at': '2016-11-03T03:35:09.042Z', 'author': { 'loginname': 'tofishes', 'avatar_url': '//gravatar.com/avatar/9ddb719150550dc3ed573dd7392561fc?size=48' } }, { 'id': '5cf08cd44036f24194cf8369', 'author_id': '575e5645c1518403160a4584', 'tab': 'ask', 'content': '<div class="markdown-text"><p>有3台设备。</p>\n<ol>\n<li>家用的电脑</li>\n<li>一台可以通过公网访问的机器</li>\n<li>公司的电脑</li>\n</ol>\n<p>如何利用公网的机器通过 node 让家里的电脑访问公司电脑的本地服务器？\n我想到是用 socket，但是 npm 找的包都是客户端和服务端通信的，没有服务端主动发起 socket 请求的 api。</p>\n</div>', 'title': '如何通过一台公网机器访问公司电脑的本地服务器？', 'last_reply_at': '2019-06-03T13:59:59.215Z', 'good': false, 'top': false, 'reply_count': 6, 'visit_count': 559, 'create_at': '2019-05-31T02:09:24.022Z', 'author': { 'loginname': 'jamieYou', 'avatar_url': 'https://avatars2.githubusercontent.com/u/19544032?v=4&s=120' } }, { 'id': '5cf4da7495fcc914aa265a98', 'author_id': '5784971469d72f545483cb13', 'tab': 'share', 'content': '<div class="markdown-text"><p>先上 github 地址 <a href="https://github.com/4074/koa-proper">koa-proper</a></p>\n<p>最近写node服务端写多了，每个接口都要进行参数验证。\n重复代码很多，所以抽象了一个中间件。</p>\n<p>功能：</p>\n<ul>\n<li>对参数对象进行类型验证，基于 prop-types (一个react衍生的类型定义库)</li>\n<li>验证失败自动抛出 http 400 错误 (可关闭，可自定义)</li>\n</ul>\n<p>使用简单，功能实用，话不多说看代码：</p>\n<pre class="prettyprint"><code>import Koa from &#x27;koa&#x27;\nimport proper from &#x27;koa-proper&#x27;\n\nconst app = new Koa()\napp.use(proper())\n\napp.use(async ctx =&gt; {\n    &#x2F;&#x2F; 请求参数: {string: any}\n    const props = ctx.request.query\n    &#x2F;&#x2F; 定义参数类型: {string: PropType}\n    &#x2F;&#x2F; ctx.PropTypes 就是 prop-types\n    const types = {\n        username: ctx.PropTypes.string.isRequired\n    }\n\n    &#x2F;&#x2F; ctx.proper 为验证方法\n    &#x2F;&#x2F; 如果验证通过，返回原数据\n    const params = ctx.proper(props, types)\n\n    &#x2F;&#x2F; 如果失败, 会自动抛出 http error \n    &#x2F;&#x2F; 可以在 options 里关闭或者自定义\n\n    &#x2F;&#x2F; ctx.throw(400, error) &lt;---- 默认的错误抛出方法\n\n    &#x2F;&#x2F; 验证通过才会执行下面代码\n    ctx.body = params\n})\n</code></pre><p>再上 github 地址 <a href="https://github.com/4074/koa-proper">koa-proper</a></p>\n</div>', 'title': 'koa请求参数验证middlware', 'last_reply_at': '2019-06-03T13:57:40.167Z', 'good': false, 'top': false, 'reply_count': 1, 'visit_count': 205, 'create_at': '2019-06-03T08:29:40.890Z', 'author': { 'loginname': '4074', 'avatar_url': 'https://avatars2.githubusercontent.com/u/4033831?v=4&s=120' } }, { 'id': '5cf50f0a95fcc914aa265bdc', 'author_id': '5a924b1e71327bb413bbfe26', 'tab': 'ask', 'content': '<div class="markdown-text"><p>谁给个提高开发效率的PPT，简单点的</p>\n</div>', 'title': '提高开发效率PPT有没有', 'last_reply_at': '2019-06-03T12:14:02.432Z', 'good': false, 'top': false, 'reply_count': 0, 'visit_count': 175, 'create_at': '2019-06-03T12:14:02.432Z', 'author': { 'loginname': 'six-666', 'avatar_url': 'https://avatars0.githubusercontent.com/u/36760287?v=4&s=120' } }, { 'id': '5cee2dc34036f24194cf78e2', 'author_id': '55adc069b4ab1d7d02bf0e49', 'tab': 'share', 'content': '<div class="markdown-text"><p>时光荏苒，腾讯 Live 开发者大会（以下简称 TLC 大会）即将迎来第三届举办，对技术感兴趣的你一定不要错过这个绝好的、与千万开发者线上线下深度交流的机会。</p>\n<h1><strong>TLC 大会简介</strong></h1>\n<p>TLC大会是由腾讯直播&amp;NOW直播IVWEB团队精心打造，致力于提升和促进全行业音视频、直播、图像处理、大前端、信息流等领域的交流和技术创新。</p>\n<p>本届 TLC 大会的主题是 <strong>“大前端，信息流”</strong>，将于 <strong>2019年8月17日</strong> 在深圳科兴科学园国际会议中心举办，会议持续1天。</p>\n<p>更多信息，前往大会官网：<a href="https://2019.tlc.ivweb.io/">https://2019.tlc.ivweb.io/</a>。</p>\n<p>大会早鸟票：<strong>199元</strong>，购票链接：<a href="https://www.bagevent.com/event/2596495#website_moduleId_258989">https://www.bagevent.com/event/2596495#website_moduleId_258989</a>\n<img src="//static.cnodejs.org/Ft3osFGWYVEG04zeiKCsOXgrRBSJ" alt="7YDVwf2DJAkmc9qS__thumbnail.jpg"></p>\n<h1><strong>精彩议题介绍</strong></h1>\n<p>前端技术日新月异，如何在技术浪潮中打造核心竞争力？大前端还火吗？跨端如何选型？这些知识点，由TLC大会明星讲师们统统告诉你~</p>\n<p><img src="//static.cnodejs.org/FnQz24UC51eskrmPWZPfkz30KQ4X" alt="winter.jpg"></p>\n<p>大家平时开发业务难免会和设计师打交道，希望设计能够尽可能规范化，从而让前端组件复用；为了应对业务变化，也会使用JSON配置；全栈技术的流行，也会有不少前端开发想跳出舒适圈去做后端的事情。那么这个过程中会存在什么问题呢？来自 <strong>前手机淘宝前端负责人 winter 老师</strong>将会和大家聊聊技术管理中的思考。</p>\n<h2>探索动效开发模式</h2>\n<p><img src="//static.cnodejs.org/FkY7PfAHanf7r0qlSrPKRSD9mVXn" alt="damo.jpg"></p>\n<p>动效对于Web应用而言很多时候能做到锦上添花，但对于一个互动动效而言，动效是他的灵魂之一。面对众多的动效开发方式，如何寻找一种最适合自己的动效开发？如何更好，更快速的开发？这是我们应该一起去探讨的主题，来自<strong>阿里巴巴的前端专家大漠</strong>将会和大家一起聊聊他近几年对动效开发模式的思考。</p>\n<h2>Vue.js 高效开发之路</h2>\n<p><img src="//static.cnodejs.org/FnPhk5eta5Dw9ezmrow041cyU2kC" alt="jianghaoqun.jpg"></p>\n<p>Vue.js 早已成为前端开发最流行的框架之一，本次我们邀请到来自 <strong>Vue.js 官方团队的蒋豪群</strong>，他将会介绍 Vue.js 开发实践中的各类提效技巧，包括代码实践、工具使用和调试技巧等。</p>\n<h2>使用 Node.js 构建 Serverless 框架</h2>\n<p><img src="//static.cnodejs.org/Fp05_j4SCjCvgr5cssaAJga1AyfT" alt="longjiawen.jpg"></p>\n<p>Serverless 是19年大热的技术之一，来自<strong>美团点评的高级前端工程师龙佳文</strong>将会介绍在团队大量使用 Node.js 开发前后端分离的项目背景之下采用 Serverless 方案来降低底层系统的维护成本的思考和实践。</p>\n<h2>用 React Hooks 重构你的小程序</h2>\n<p><img src="//static.cnodejs.org/FthGLF61BrN42SqRONTZwwdMbheP" alt="liweitao.jpg"></p>\n<p>React v16.7.0 版本推出了 React Hooks用来解决前端工程的复杂度，Vue 3.0的 RFC 也规划了类似的API。来自 <strong>京东的Taro 框架作者李伟涛</strong>  将会介绍Taro 对 Hooks 的探索，如何通过 Hooks API摒弃掉 ES6 class 和其它框架的高阶组件、依赖注入等功能。从而将小程序开发的复杂业务逻辑化简为一个个可预测的、可测试的普通函数。</p>\n<h2>多端一体方案 Hippy 的架构和实战</h2>\n<p><img src="//static.cnodejs.org/FvFs3LmipbiBb0j1GBl9cENAi86o" alt="kuangxuqing.jpg"></p>\n<p>Hippy 从设计方向上从一开始就和现有的框架有所区别，更加照顾传统的前端开发者以及 NodeJS 开发者，而这就体现在架构的设计上一开始就不一样，来自<strong>腾讯高级工程师旷旭卿</strong> 将会介绍 Hippy 的设计理念和业务实战。</p>\n<h2>Flutter桌面应用开发</h2>\n<p><img src="//static.cnodejs.org/Frs9JtrYHt0oJ5RfuFmJ0TE8g0bs" alt="guolihengj.jpg"></p>\n<p>Flutter是 Google 出品的一项移动端跨平台开发技术，已经成功运用到多个业界多个移动端产品中。随着flutter技术的普及，社区生态的日益健壮，Flutter成为多端开发方案只是时间问题。本次分享来自<strong>广发证券高级前端工程师郭力恒</strong>将会介绍 Flutter 在桌面运行的优势，现状，并介绍如何使用跨端开发语言 Rust 开发桌面 Flutter 运行环境。</p>\n<h2>高可用Nodejs平台的原理与演进</h2>\n<p><img src="//static.cnodejs.org/Fl3klOV9-vEAhE9aQUozoU7iHzpJ" alt="zhanglong.jpg"></p>\n<p>作为一个日调用量超700亿的Nodejs平台，如何保证服务的稳定性和可用性？本次分享来自<strong>腾讯高级工程师张龙</strong>将以平台开发者的视角回顾各种技术要点的选型和实现策略，总结多年以来的经验教训，搭建高可用易扩展的Nodejs平台</p>\n<h2>基于WebAssembly的浏览器端视音频处理</h2>\n<p><img src="//static.cnodejs.org/FmrKi8Rf1c25mKrYspItpeXWXRR7" alt="xiamengli.jpg"></p>\n<p>淘宝直播中每月视频带宽成本费用在百万至千万左右，在业务快速发展的同时，团队尝试用压缩率更高的H.265视频编解码格式，本次分享来自<strong>淘宝高级前端工程师夏梦丽</strong>将会介绍选用WebAssembly的跨平台及相对较高性能的方案来集成现有成熟视音频开源c语言框架FFmpeg的能力来扩展浏览器视频播放能力，及如何快速支持各种视频格式及编码格式视频播放。</p>\n<p><strong>票务信息</strong></p>\n<p>本次大会有四种类型的门票，分别是：早鸟票（199）、全价票（399）、学生票（169），团体票。需要说明的是：购买学生票的同学现场签到时需要提供学生证；团体票三张起售，一次性购买数量越多价格更加优惠哦。</p>\n<p>购票链接：<a href="https://www.bagevent.com/event/2596495#website_moduleId_258989">https://www.bagevent.com/event/2596495#website_moduleId_258989</a></p>\n<p><strong>说明</strong></p>\n<ol>\n<li>TLC大会是非盈利性的技术交流大会，门票收入将用于大会场地租赁、讲师差旅、纪念品和奖品发放。</li>\n<li>大会早鸟票： <strong>199</strong>元/人</li>\n<li>今年我们特别推出了邀请码机制，每位购票成功的用户都能获得一个邀请码（加官方QQ：1026914525获取），用户邀请其他好友购票可以获得每张5元的返现，用户好友使用邀请码购票可以获得5元票价优惠。返现不设上限。</li>\n</ol>\n<p>票务事宜及本次大会的最终解释权归IVWEB组委会所有。</p>\n</div>', 'title': '腾讯2019 TLC 众多技术大咖等你参会，早鸟票5折售卖中', 'last_reply_at': '2019-06-03T11:36:46.701Z', 'good': false, 'top': false, 'reply_count': 14, 'visit_count': 890, 'create_at': '2019-05-29T06:59:15.595Z', 'author': { 'loginname': 'chyingp', 'avatar_url': 'https://avatars1.githubusercontent.com/u/2383346?v=4&s=120' } }, { 'id': '5cf4fcc41fe902120f31bbe3', 'author_id': '581ae153e90cfbec054d762a', 'tab': 'share', 'content': '<div class="markdown-text"><p><img src="https://user-gold-cdn.xitu.io/2019/6/3/16b1cf9bee07ace3?w=1790&amp;h=898&amp;f=png&amp;s=2102071" alt="image.png"></p>\n<p>【阿里云 TXD 前端月刊】- 热门前端技术快报，聚焦业界新视界；五月清风徐来，跟我们一起来看一看新的风向即将吹向何方，前端的技术力量又将影响哪些新的领域。</p>\n<blockquote>\n<p>欢迎 <a href="https://zhuanlan.zhihu.com/txd-team">订阅</a> &amp; <a href="https://github.com/txd-team/monthly/issues">投稿</a>\n编辑：<a href="https://github.com/damujiangr">墨止</a>\n审稿：<a href="https://github.com/x-cold">尹挚</a></p>\n</blockquote>\n<h3>学习专栏</h3>\n<h4><a href="https://yq.aliyun.com/articles/700174">《</a><a href="https://yq.aliyun.com/articles/700174">深入浅出 React Hooks</a><a href="https://yq.aliyun.com/articles/700174">》</a></h4>\n<p>React 16.8 了，还不了解 React Hooks？！想做前端极客，想写出酷酷的代码，那就赶紧跟 <a href="https://github.com/x-cold">@x-cold</a> 一起来学习最新的 Hooks 知识吧！原文章看<a href="https://juejin.im/post/5cf475d66fb9a07ea944594e">这里</a>，一步步进入 React Hooks 的世界。</p>\n<h4><a href="https://juejin.im/post/5cef46226fb9a07eaf2b7516">《一个合格的中级前端工程师必须要掌握的 28 个 JavaScript 技巧》</a></h4>\n<p>对在毕业季还在找工作的同学，可以说很实用的，如果能全部掌握这些技巧，拿到几个offer应该是没有问题的，当然要注意平时的积累，能力要全面。</p>\n<h4><a href="https://github.com/Q-Angelo/Nodejs-Roadmap">《Node.js 技术栈》</a></h4>\n<p>这是作者从事 Node.js Developer 以来的学习历程，旨在为大家提供一个较详细的学习教程，侧重点更倾向于 Node.js 服务端所涉及的技术栈，如果本文能为您得到帮助，请给予支持！</p>\n<h3>新闻快报</h3>\n<h4>Github 重磅推出包管理仓库</h4>\n<p><img src="https://cdn.nlark.com/yuque/0/2019/gif/106292/1559291181359-440a4c28-6d31-4942-bb8e-155f7b50b3d3.gif#align=left&amp;display=inline&amp;height=420&amp;name=May-31-2019%2016-24-50.gif&amp;originHeight=420&amp;originWidth=820&amp;size=726404&amp;status=done&amp;width=820" alt="May-31-2019 16-24-50.gif"></p>\n<p>现在使用 Github，你的团队可以发布公共/私有的包到 Github 提供的包管理仓库，目前包含的类型有 Npm, Docker, Maven, NuGet, RubyGems等，更多的类型还在继续添加中。而且该托管服务是完全免费的。<a href="https://github.com/features/package-registry">[戳👇传送门]</a></p>\n<h4>Flutter 实现 Web 访问，新增桌面和嵌入式的应用场景</h4>\n<p>2019 谷歌 I/O 大会上，Flutter Team 公布了 Flutter 可进行 Web 访问、提供自定义图像分类模型等诸多新特性，并且可以应用在桌面系统及嵌入式设备中，给未来提供了更多的想象空间，展现了 Flutter 从移动 UI 到制霸多平台的雄心。Flutter for Web 已发布第一个预览版本，可以查看官网信息进行尝鲜，体验惊喜 <a href="https://flutter.dev/web">[惊喜门]</a>。在 Facebook 年度开发者大会上宣布了会稳定支持 RN，但是 RN 还要继续步履蹒跚吗？</p>\n<h4>HTML 和 DOM 标准统一</h4>\n<p>W3C 宣布与 WHATWG 达成协议，HTML 和 DOM 标准都以 WHATWG 为准，也就是说以后只有一套 HTML 标准了。正所谓分久必合，合久必分，不过对大多数的框架工程师影响不是很大（扎心了） <a href="https://www.w3.org/blog/news/archives/7753">[戳👇传送门]</a></p>\n<h4>Now and the Future: An Overview of the Web in 2019</h4>\n<p>W3C Web 技术总负责人 Philippe Le Hégaret 在 QCon 2019 全球软件开发大会做的分享，介绍了Web 技术当前关注的技术方向，未来 W3C 更着力拓展新的领域，其中最重要的一项是汽车互联网，期望打造适用于车联网的 通用的 Web 技术方案。在拓展核心能力方面，有 WebRTC（视频通话）、Web Assembly（性能、语言生态）、WebPerf（性能管理）、Service Workers（离线）、Web Components（组件） 等等，前景如此美好，真的希望文中描述的技术能早日落地，给前端开发者们带来福音。<a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247491186&amp;idx=1&amp;sn=235f648fccaf0e2769fa5044418a8b4d&amp;chksm=f951ab31ce262227a867bdaeaa9d967f2be0272108ef51cfdd9fd7c5118dbcb7201b56ded254&amp;mpshare=1&amp;scene=2&amp;srcid=05090EIW4SEAUAWYJrESqW58&amp;from=timeline&amp;as">[传送门]</a></p>\n<h4>Ant Design 4.0 进行时！</h4>\n<p>Ant Design 团队发布 4.0 开发规划，将使用最新的 React API，放弃 IE9/10 浏览器的支持，同时会增加设计资产管理的工具包，预计后续设计师就可以参考到这些资源了</p>\n<h3>工具推荐</h3>\n<h4>微软发布 Windows Terminal</h4>\n<p>微软正在推出一款名为 Windows Terminal 的新命令行终端工具。它被设计为访问 PowerShell、 Cmd 和 Windows Linux 子系统（WSL）等环境。微软正在为想要调整终端工具的开发人员添加多个选项卡、分割窗口、快捷键支持，另外支持主题和自定义等等。微软这款新的 Windows 终端应用程序在 Build 2019 开发者大会上公布了。<a href="https://devblogs.microsoft.com/commandline/introducing-windows-terminal/">[戳👇传送门1]</a> 、<a href="https://github.com/microsoft/Terminal">[戳👇传送门2]</a></p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/6/3/16b1cf9bef4b4453?w=728&amp;h=470&amp;f=png&amp;s=598691" alt="image.png"></p>\n<h4>VSCode  添加 Remote Development 特性</h4>\n<p>使用 Remote Development 特性，开发者可以在远程环境下进行开发和调试，同时具备代码高亮和补充功能，跟在本地使用一样</p>\n<h4>EdgeDB - The next generation database</h4>\n<p>EdgeDB 结合了 NoSQL 数据库的简单性，关系模型强大的查询、严格、一致性和性能。天然支持 GraphQL 哦。数据库选型又多了一份选择。<a href="https://edgedb.com/">[戳👇传送门]</a></p>\n<h4>基于 Operational Transformation 的实时数据库 sharedb</h4>\n<p>ShareDB is a realtime database backend based on <a href="https://en.wikipedia.org/wiki/Operational_transformation">Operational Transformation (OT)</a> of JSON documents. It is the realtime backend for the <a href="http://derbyjs.com/">DerbyJS web application framework</a>.</p>\n<h4>create-react-app 发布 3.0</h4>\n<p>支持了 React Hooks 的代码风格校验、TypeScript Lint、Jest 24，Hooks 语法可以很方便的用起来了<a href="https://github.com/facebook/create-react-app/releases/tag/v3.0.0">[Release 日志]</a></p>\n<h3>热门文章</h3>\n<h4><a href="https://mp.weixin.qq.com/s/LJoFj_XbaOqpiiGL1xevVg">《前端能力中台化之路—Fusion Design 成长史》</a></h4>\n<p>FDCON 2019 演讲的提炼版本，介绍了前端组件库 Fusion Design 的成长演变之路，还有诸多特性的背后的思考，包括对未来的一些探索</p>\n<h4><a href="https://mp.weixin.qq.com/s/Z2NDVA_UdsRCS8kgy8ejow">《探索 Serverless 中的前端开发模式》</a></h4>\n<p>前端工程师永远在打破边界，在 Web 、App、桌面和服务端等方面都已经伸出了触角，Serverless 的出现，又能在前端圈引领什么样的风向和潮流呢</p>\n<h4><a href="https://juejin.im/post/5cea1f705188250640005472">《大型项目前端架构浅谈（8000字原创）》</a></h4>\n<p>文中从基础层设计到应用层设计的多种方案、平台等做了简单的介绍，从宏观方面介绍了一个大型前端架构的雏形，可以在自己进行技术设计的做一个参考</p>\n<h4><a href="https://zhuanlan.zhihu.com/p/67087685">《精读《Function Component 入门》》</a></h4>\n<p>如果你将要使用或者已经开始使用 React 16了，那么小编我推荐来读一下这篇文件，从传统的 Class Component 思维方式转变一下，开始使用 Function Component ，使用 Hooks 来搭建自己的 React 应用吧。</p>\n<h3>小趣味</h3>\n<h4>IE 所有版本的下载链接</h4>\n<p>一个 IE 爱好者收集了 IE1～IE12、EDGE 的所有下载链接，新版的 IE 已经拥抱 Chromium 了，传统的IE即将进入“博物馆”，IE 爱好者过来围观吧。<a href="https://www.my-internet-explorer.com/edge/">[IE 时光机]</a></p>\n</div>', 'title': '将函数式进行到底，用 Hooks 武装组件 - TXD 前端月刊 201905 期', 'last_reply_at': '2019-06-03T10:56:04.862Z', 'good': false, 'top': false, 'reply_count': 0, 'visit_count': 188, 'create_at': '2019-06-03T10:56:04.862Z', 'author': { 'loginname': 'x-cold', 'avatar_url': 'https://avatars1.githubusercontent.com/u/6903313?v=4&s=120' } }, { 'id': '5cf4eb8e1fe902120f31bb6e', 'author_id': '577093d3d3baaf401780bbcf', 'tab': 'share', 'content': '<div class="markdown-text"><h2>BabyDay</h2>\n<blockquote>\n<p>背景：宝宝出生后，想着做一款比较漂亮的喂养数据记录工具，用于记录宝宝的日常数据，关心宝宝每天的成长。\n项目地址：  <a href="http://www.wetalks.cn/babyDay">http://www.wetalks.cn/babyDay</a>\ngithub地址：<a href="https://github.com/liuyahuiZ/babyDay">https://github.com/liuyahuiZ/babyDay</a>\n主要功能：宝宝的信息录入，编辑、 每天的喂养记录数据、 喂养记录数据的管理、 喂养记录类型的管理、喂养记录数据可视化</p>\n</blockquote>\n<h4>技术架构</h4>\n<p>前端目前是移动web版，基于React开发，UI组件是自主研发的neo-ui，icon字体化，\n图表简单的调用了一下 阿里的图表库 F2</p>\n<p>neo-ui地址 <a href="http://www.wetalks.cn/neo-ui/">http://www.wetalks.cn/neo-ui/</a></p>\n<p>后端Api是基于koa2+mongodb开发的 server-koa\ngithub地址 <a href="https://github.com/liuyahuiZ/server-koa">https://github.com/liuyahuiZ/server-koa</a></p>\n<h4>效果图</h4>\n<h5>喂养部分</h5>\n<p>&lt;div&gt;\n&lt;img width=‘40%’ src=“<a href="https://neo-blick.oss-cn-shanghai.aliyuncs.com/698FC8EDC04BCCDBCE1A6ECFAD3C775C.png?Expires=1559556405&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=EfYgw%2BAfSlh5VsgFVVe7oSV6Y6E%3D">https://neo-blick.oss-cn-shanghai.aliyuncs.com/698FC8EDC04BCCDBCE1A6ECFAD3C775C.png?Expires=1559556405&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=EfYgw%2BAfSlh5VsgFVVe7oSV6Y6E%3D</a>”/&gt;\n&lt;img width=‘40%’ src=“<a href="https://neo-blick.oss-cn-shanghai.aliyuncs.com/WechatIMG270.jpeg?Expires=1559556684&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=oTbA%2BJAVwkqrBu96uXrfUvwRCVE%3D">https://neo-blick.oss-cn-shanghai.aliyuncs.com/WechatIMG270.jpeg?Expires=1559556684&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=oTbA%2BJAVwkqrBu96uXrfUvwRCVE%3D</a>”/&gt;\n&lt;/div&gt;</p>\n<p>&lt;div&gt;\n&lt;img width=‘40%’ src=“<a href="https://neo-blick.oss-cn-shanghai.aliyuncs.com/C8C19B5E22F0283FE5FA6E2BAFB09B88.png?Expires=1559556384&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=65EdQjxR2xNKNlU7zj5sudBNrXc%3D">https://neo-blick.oss-cn-shanghai.aliyuncs.com/C8C19B5E22F0283FE5FA6E2BAFB09B88.png?Expires=1559556384&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=65EdQjxR2xNKNlU7zj5sudBNrXc%3D</a>”/&gt;\n&lt;img width=‘40%’ src=“<a href="https://neo-blick.oss-cn-shanghai.aliyuncs.com/EC337A49835CD0DFB97CBB401C95297A.png?Expires=1559556366&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=OotUrz43B5LK5tSIMl%2F3y6MuppU%3D">https://neo-blick.oss-cn-shanghai.aliyuncs.com/EC337A49835CD0DFB97CBB401C95297A.png?Expires=1559556366&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=OotUrz43B5LK5tSIMl%2F3y6MuppU%3D</a>”/&gt;\n&lt;/div&gt;</p>\n<p>&lt;div&gt;\n&lt;img width=‘40%’ src=“<a href="https://neo-blick.oss-cn-shanghai.aliyuncs.com/47465BAF2A55AAFF844CD054FE84795E.png?Expires=1559556418&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=R7O6OG5Bv6iah7QU8Drwz%2B1NwKU%3D">https://neo-blick.oss-cn-shanghai.aliyuncs.com/47465BAF2A55AAFF844CD054FE84795E.png?Expires=1559556418&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=R7O6OG5Bv6iah7QU8Drwz%2B1NwKU%3D</a>”/&gt;</p>\n<p>&lt;/div&gt;</p>\n<h5>音乐部分</h5>\n<p>线上地址：<a href="http://www.wetalks.cn/babyDay/#/MusicCategory">http://www.wetalks.cn/babyDay/#/MusicCategory</a>\n后端api是调用该大神提供的网易音乐接口 <a href="https://github.com/Binaryify/NeteaseCloudMusicApi">https://github.com/Binaryify/NeteaseCloudMusicApi</a>\n&lt;div&gt;\n&lt;img width=‘40%’ src=“<a href="https://neo-blick.oss-cn-shanghai.aliyuncs.com/3191559551068_.pic.jpg?Expires=1559556499&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=NDlr%2Ftj4ULCIpjOMwndvK3T7Q0c%3D">https://neo-blick.oss-cn-shanghai.aliyuncs.com/3191559551068_.pic.jpg?Expires=1559556499&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=NDlr%2Ftj4ULCIpjOMwndvK3T7Q0c%3D</a>”/&gt;\n&lt;img width=‘40%’ src=“<a href="https://neo-blick.oss-cn-shanghai.aliyuncs.com/3141559291635_.pic.jpg?Expires=1559556534&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=anR3cylPPdrjmviPETEP3TQvW44%3D">https://neo-blick.oss-cn-shanghai.aliyuncs.com/3141559291635_.pic.jpg?Expires=1559556534&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=anR3cylPPdrjmviPETEP3TQvW44%3D</a>”/&gt;\n&lt;/div&gt;</p>\n<p>&lt;div&gt;\n&lt;img width=‘40%’ src=“<a href="https://neo-blick.oss-cn-shanghai.aliyuncs.com/3201559551069_.pic.jpg?Expires=1559556554&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=TfBHB%2F6W8wLIfilhzirYieXKHJE%3D">https://neo-blick.oss-cn-shanghai.aliyuncs.com/3201559551069_.pic.jpg?Expires=1559556554&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=TfBHB%2F6W8wLIfilhzirYieXKHJE%3D</a>”/&gt;\n&lt;img width=‘40%’ src=“<a href="https://neo-blick.oss-cn-shanghai.aliyuncs.com/3211559551070_.pic.jpg?Expires=1559556563&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=GxxzkmM7pTpTNWH93rix4OBJANY%3D">https://neo-blick.oss-cn-shanghai.aliyuncs.com/3211559551070_.pic.jpg?Expires=1559556563&amp;OSSAccessKeyId=TMP.AgErF1D4xZVX0WaPbjz47kAw5Oe895UN3zeM6Ikoz9D7ee-VWL96ibdWjOrTADAtAhQVlsFM2UEsti4xZZ2aCvH_VdJ-5gIVANYRA3qh0qWTVWV6RE9-XbLr1AFa&amp;Signature=GxxzkmM7pTpTNWH93rix4OBJANY%3D</a>”/&gt;\n&lt;/div&gt;</p>\n<h4>目录结构</h4>\n<pre class="prettyprint"><code>├── cgiMock   接口模拟工具\n│   ├── test.json 模拟文件\n│   └── token.json\n├── package-lock.json\n├── package.json\n├── readme.md\n├── src\n│   ├── App 项目主目录\n│   │   ├── Allroutes.js  路由配置文件\n│   │   ├── api 接口分离\n│   │   ├── components 公用组件\n│   │   ├── config  公用配置\n│   │   ├── core  核心模块\n│   │   ├── page  所有页面目录\n│   │   ├── servise  服务层 请求，加密\n│   │   ├── style  公用样式\n│   │   └── utils  工具方法\n│   ├── index.html\n│   ├── index.js\n│   └── neo UI框架\n│       ├── Components 基础组件\n│       ├── Parts 高阶组件\n│       ├── Style \n│       ├── index.js\n│       └── utils\n├── test.sh\n├── tools\n│   └── localServer.js\n├── webpack.config.js\n└── webpack.config.pro.js\n</code></pre></div>', 'title': '用于记录宝宝日常数据的小应用，内附音乐播放器，欢迎star', 'last_reply_at': '2019-06-03T09:42:38.437Z', 'good': false, 'top': false, 'reply_count': 0, 'visit_count': 200, 'create_at': '2019-06-03T09:42:38.437Z', 'author': { 'loginname': 'liuyahuiZ', 'avatar_url': 'https://avatars2.githubusercontent.com/u/11780645?v=4&s=120' } }, { 'id': '5cef9f6f4036f24194cf805c', 'author_id': '5c875af8acb681372d41753b', 'tab': 'share', 'content': '<div class="markdown-text"><p>Dart教程在线试听地址： <a href="https://www.bilibili.com/video/av52490605">https://www.bilibili.com/video/av52490605</a></p>\n<p>Flutter教程在线试听地址： <a href="https://www.bilibili.com/video/av52490605/?p=15">https://www.bilibili.com/video/av52490605/?p=15</a></p>\n<p><strong>2019年5月新出Dart Flutter入门实战视频教程网盘下载地址：</strong></p>\n<p><a href="https://pan.baidu.com/s/1WCobyt_1Oy4KDUmnSsCpiw">https://pan.baidu.com/s/1WCobyt_1Oy4KDUmnSsCpiw</a>  提取码：xwpq</p>\n</div>', 'title': '2019年5月录制的Dart Flutter入门实战系列视频教程-网盘免费分享', 'last_reply_at': '2019-06-03T09:14:54.065Z', 'good': false, 'top': false, 'reply_count': 6, 'visit_count': 521, 'create_at': '2019-05-30T09:16:31.065Z', 'author': { 'loginname': 'youmenglinzi', 'avatar_url': 'https://avatars0.githubusercontent.com/u/48469369?v=4&s=120' } }, { 'id': '5cf076ce52ccb64168ba90f8', 'author_id': '5c85d4b2acb681372d416dd6', 'tab': 'share', 'content': '<div class="markdown-text"><h2>资讯：原美图技术副总裁洪小军加入 AfterShip 出任 CTO。</h2>\n<p>欢迎各位加入。可在拉勾或者 boss 搜索 aftership 了解详细的岗位，或者直接发 CV 到我们的邮箱： <a href="mailto:xh.wang@aftership.com">xh.wang@aftership.com</a></p>\n<p>洪小军的职业生涯历经飞信、微博、美图这几个公司的关键发展历程，完整的经历了移动互联网发展的十年，今天我们有机会采访到他，聊他这一次的职业选择，同时也进一步了解他选择的这家公司。</p>\n<h2>洪小军是谁？— AfterShip CTO</h2>\n<h2>曾任：</h2>\n<p>美图 技术副总裁</p>\n<p>微博 平台架构团队负责人</p>\n<p>中国移动飞信 架构师</p>\n<h2>技术影响力：</h2>\n<p>厦门 TGO 鲲鹏会第一任会长</p>\n<p>全球架构师峰会优秀出品人</p>\n<p>顶级技术大会分享议题和出品专题</p>\n<p>[全球软件开发大会 /全球架构师峰会 /全球互联网架构大会]</p>\n<p>“对于我而言，虽然技术一直是舒适区，但是我也期望在产品、市场、客户等很多领域都能有所突破，创造更大的价值。“ — AfterShip CTO 洪小军</p>\n<h2>AfterShip 是做什么的？</h2>\n<p>AfterShip （爱客科技）：是一个为国际性电商企业而设的 B2B 的 SaaS 平台，通过提供全方位和全自动化的工具，帮助电商降低营运成本及实现智能营销。公司全自动化系统涵盖市场推广、订单管理、运单打印、快递跟踪及退换货管理等。</p>\n<h2>这家公司有多厉害呢？</h2>\n<p>支持 30 多种语言 覆盖 200 多个国家 对接 500 多家快递公司 为 Amazon, eBay, Wish, IKEA 等 全球 100,000 多家企业提供服务</p>\n<p>Google 搜索“包裹跟踪” 排名第一就是这家公司</p>\n<p>So，在核心技术备受瞩目的今天 AfterShip 是如何从创业公司起步， 最后跻身成为 国际包裹查询的龙头企业呢？ 每年营收翻番的背后， 又有怎样的用人之道呢？</p>\n<h2>听小军讲 AfterShip 过硬技术背后的独特魅力</h2>\n<h3>Q1：为什么选择的是 AfterShip 呢？</h3>\n<p>小军：创业⼀直是我的梦想，同时我这一次的职业选择是综合行业发展趋势、⼈才发展方向和团队氛围综合考虑的，而 AfterShip 跟我的想法⽐较契合。</p>\n<p>海外有超过 500 万家以上的电商企业，面向这个领域的 SaaS 有很大的市场空间，AfterShip 在物流跟踪等领域已经做到全球领先，并且也取得很好的客户信任度，这很有利于接下来更进一步开拓市场及其为客户提供更全方位的服务。这个阶段的公司给到个人和团队的机会都比较多。 除此之外，公司对技术的要求和团队氛围我也比较看重。很多优秀的技术⼈会有一些好的习惯和做事方式，在好的技术氛围⾥在能带来新的成长和突破。</p>\n<h3>Q2：对于你管理的团队，你是怎么去做团队技术氛围建设的？</h3>\n<p>小军：要让团队成员有更多的成长空间，要让员工工作起来有成就感。</p>\n<p>一方面在组建团队的时候，我会考虑队员之间的优势互补，同时会指出个人的一些不足，挖掘每个人的优点，给他们空间去成长和创造价值，帮助团队成员分析梳理个人规划。</p>\n<p>另一方面通过在公司内部构建体系化分享和交流氛围，带动公司内部形成很好的技术交流和学习氛围。比如牵头组织持续的高质量技术文章输出，推动公司更多人去顶级技术大会分享议题等。</p>\n<h3>Q3：加入这家公司，你接下来对自己的定位是什么？</h3>\n<p>小军：从发展的角度来看，具有多领域知识和经验，并具有国际化视野的复合型人才将会是未来所需要的核⼼人才。在未来也期望⾃己是更加复合型的⼈，在技术之外，期望在产品、市场、客户等很多领域都能有所突破，并且也让⾃己也更加国际化。</p>\n<h3>Q4：可以说几点 AfterShip 跟其他公司不同的地方吗？</h3>\n<p>1、公司 CEO Teddy 本身是一个极具极客精神的⼯程师，因⽽公司的⼯程师⽂化比较好，崇尚开源，并且有浓厚的⼯具化文化。公司具有多元文化，不断在探索如何实现中⻄方文化的优势互补，对于团队建设和个⼈成⻓也都会有优势。</p>\n<p>2、公司 2012 年成⽴⾄今成⽴ 7 年的时间，是没有销售团队，也没有做任何的付费推⼴之类的。但是从 2014 年开始盈利，并且做到了细分领域的第一，现在合作的包含⼀些国际知名平台和品牌，⽐如说:Amazon, Wish, eBay, Yahoo, IKEA, PUMA 等。这⼀点跟国内的大多数公司都不太一样。</p>\n<h3>Q5：团队情况现在是怎么样的？</h3>\n<p>小军：在香港、深圳和印度都有团队，团队成员有来自十几个不同国家的。</p>\n<h3>Q6：那 AfterShip 是怎么吸引更多的牛人呢？</h3>\n<p>小军：除了帮助员工成长，让他有一个好的发展空间之外，我们在企业福利方面给了员工跟多的选择权。比如：办公设备标配 Apple MacBook Pro+LG 真 4K 显示器、不限额学习成长基金、每月的团队聚餐基金、每天下午茶、定期体检和不定期外出旅游、可以使用各种国际正版付费工具等。</p>\n<h3>Q7：除了福利待遇方面，在 AfterShip 工作还会有哪些收获？</h3>\n<p>小军：当前公司业务正处于快速发展的阶段，在这个时间加入我们其实是一个很好的机会，可以有机会和公司共同成长。</p>\n<p>在这里，可以和一群有极客精神的小伙伴共事，体验纯正的开源和工程师文化。并且开发的是全球性项目，有很多机会去学习新的技术，可以拓展个人的技术视野和能力。</p>\n<h3>Q8：那你们对人才的要求是怎么样的呢？</h3>\n<p>小军：我们服务的客户既包括 Amazon, eBay 等⼤客户，也包括⼤量的⻓尾客户，极致的产品细节优化、体验优化和自动化⼀直是我们公司的产品核⼼竞争力，所以我们对代码的质量和产品开发流程⾮常的重视，倡导通过⼯具来量解决更多问题，让整体更加自动化。 所以我们希望加⼊我们的⼩伙伴他有技术热情，有快速的学习能⼒，可以不断去提升他的各⽅面能⼒，来更好帮助公司和让⾃己更快的成长。</p>\n<h3>Q9：你对即将去新的环境工作的人有什么建议？</h3>\n<p>小军：每个人在成长的过程中都会面临很多新的发展机会，会面临岗位和工作内容的变化，在做选择之前，需要对于即将面临选择的新岗位有更清晰全面的认知，同时也需要提前去为新岗位做尽可能多的准备工作，迎接新的岗位后也需要尽快做好角色转变。</p>\n<p>机会总是更倾向于给有准备的人。一些大公司比如 Google, Facebook 招人有个很关键的评估标准是：“你是不是已经在过去的半年或者一年里，按照下一个级别的标准在工作。”</p>\n<p>所以不仅仅是要站在所处的岗位级别去思考问题，至少要站在下一级甚至更下一级去思考问题。</p>\n<h2>没有过硬的技术终究会“昙花一现”。而过硬的技术，始终是 AfterShip 的核心竞争力。</h2>\n<p>人才是企业的第一资源。识别人才，给人才提供舒适的工作氛围，更多的学习机会，从而发挥人才的作用，企业才能更好的发展。 AfterShip 在这两方面都尽心在做。相信 AfterShip 在未来会走的更远。</p>\n</div>', 'title': '这家前美图技术副总裁入职的公司值得你关注', 'last_reply_at': '2019-06-03T08:57:17.521Z', 'good': false, 'top': false, 'reply_count': 8, 'visit_count': 809, 'create_at': '2019-05-31T00:35:26.404Z', 'author': { 'loginname': 'wangxihua916', 'avatar_url': 'https://avatars0.githubusercontent.com/u/37897167?v=4&s=120' } }, { 'id': '5cf22e861fe902120f31b25f', 'author_id': '58bd6b91d282728c0ec401b4', 'tab': 'ask', 'content': '<div class="markdown-text"><p>如果使用 return next() 会出现什么问题影响吗？ 假定 next() 下面没有需要继续执行的代码，next()本来就在最后一行。\n(纠结的原因，如果可以用 return next() ，我就不需要在函数前面加 async了, hahaha)</p>\n</div>', 'title': '求教： Koa2里 使用await next()和return next()有没有区别？', 'last_reply_at': '2019-06-03T07:18:30.349Z', 'good': false, 'top': false, 'reply_count': 6, 'visit_count': 538, 'create_at': '2019-06-01T07:51:34.761Z', 'author': { 'loginname': 'chengshubei', 'avatar_url': 'https://avatars3.githubusercontent.com/u/24501068?v=4&s=120' } }, { 'id': '5c0a92e415a4d545e3f4c5d7', 'author_id': '5bc9f0ca9545eaf107b9ccdd', 'tab': 'ask', 'content': '<div class="markdown-text"><p>要怎么去学习</p>\n</div>', 'title': '如何学习angular', 'last_reply_at': '2019-06-03T06:40:30.759Z', 'good': false, 'top': false, 'reply_count': 28, 'visit_count': 2912, 'create_at': '2018-12-07T15:33:56.403Z', 'author': { 'loginname': 'hhffhh', 'avatar_url': 'https://avatars0.githubusercontent.com/u/3991376?v=4&s=120' } }, { 'id': '5ce5825d4036f24194cf577b', 'author_id': '5b3ed1d013ca2fe569fb9131', 'tab': 'ask', 'content': '<div class="markdown-text"><p>问题：\n我现在 balance.json 文件中的 address 引用 address.json 定义的规则，我尝试了如下的修改 “修改后的balance.json” ，但是找不到 address 规则，感谢大神指导下，网上没找到相关操作文档</p>\n<p>修改后的balance.json</p>\n<pre class="prettyprint language-js"><code>{\n  &quot;$schema&quot;: &quot;http:&#x2F;&#x2F;json-schema.org&#x2F;draft-04&#x2F;schema#&quot;,\n  &quot;title&quot;: &quot;getBalance&quot;,\n  &quot;description&quot;: &quot;Parameters for getBalances&quot;,\n  &quot;type&quot;: &quot;object&quot;,\n  &quot;properties&quot;: {\n    &quot;address&quot;: {\n      &quot;type&quot;: &quot;array&quot;,\n      &quot;items&quot;: {\n        &quot;type&quot;: &quot;object&quot;,\n        &quot;$ref&quot;:&quot;address&quot;\n      },\n      &quot;minItems&quot;: 1,\n      &quot;uniqueItems&quot;: true\n    },\n    &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; },\n    &quot;votes&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 1 }\n  },\n  &quot;additionalProperties&quot;: true,\n  &quot;required&quot;: [&quot;address&quot;]\n}\n\n</code></pre><p>balance.json</p>\n<pre class="prettyprint language-js"><code>{\n  &quot;$schema&quot;: &quot;http:&#x2F;&#x2F;json-schema.org&#x2F;draft-04&#x2F;schema#&quot;,\n  &quot;title&quot;: &quot;getBalance&quot;,\n  &quot;description&quot;: &quot;Parameters for getBalances&quot;,\n  &quot;type&quot;: &quot;object&quot;,\n  &quot;properties&quot;: {\n    &quot;address&quot;: {\n      &quot;type&quot;: &quot;array&quot;,\n      &quot;items&quot;: {\n        &quot;type&quot;: &quot;object&quot;,\n        &quot;properties&quot;: {\n          &quot;lines&quot;: {\n            &quot;type&quot;: &quot;array&quot;,\n            &quot;items&quot;: { &quot;type&quot;: &quot;string&quot; }\n          },\n          &quot;zip&quot;: { &quot;type&quot;: &quot;string&quot; },\n          &quot;city&quot;: { &quot;type&quot;: &quot;string&quot; },\n          &quot;country&quot;: { &quot;type&quot;: &quot;string&quot; }\n        },\n        &quot;required&quot;: [&quot;country&quot;]\n      },\n      &quot;minItems&quot;: 1,\n      &quot;uniqueItems&quot;: true\n    },\n    &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; },\n    &quot;votes&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 1 }\n  },\n  &quot;additionalProperties&quot;: true,\n  &quot;required&quot;: [&quot;address&quot;]\n}\n\n</code></pre><p>address.json</p>\n<pre class="prettyprint language-js"><code>{\n  &quot;$schema&quot;: &quot;http:&#x2F;&#x2F;json-schema.org&#x2F;draft-04&#x2F;schema#&quot;,\n  &quot;title&quot;: &quot;address&quot;,\n  &quot;description&quot;: &quot; &quot;,\n  &quot;type&quot;: &quot;string&quot;,\n  &quot;format&quot;: &quot;address&quot;,\n  &quot;link&quot;: &quot;address&quot;,\n  &quot;properties&quot;: {\n    &quot;lines&quot;: {\n      &quot;type&quot;: &quot;array&quot;,\n      &quot;items&quot;: { &quot;type&quot;: &quot;string&quot; }\n    },\n    &quot;zip&quot;: { &quot;type&quot;: &quot;string&quot; },\n    &quot;city&quot;: { &quot;type&quot;: &quot;string&quot; },\n    &quot;country&quot;: { &quot;type&quot;: &quot;string&quot; }\n  },\n  &quot;required&quot;: [&quot;country&quot;]\n}\n\n</code></pre></div>', 'title': 'jsonschema 引用问题', 'last_reply_at': '2019-06-03T05:47:02.873Z', 'good': false, 'top': false, 'reply_count': 4, 'visit_count': 606, 'create_at': '2019-05-22T17:09:49.766Z', 'author': { 'loginname': 'ddzyan', 'avatar_url': 'https://avatars2.githubusercontent.com/u/9130123?v=4&s=120' } }, { 'id': '5c2edce13898674067a7b103', 'author_id': '5372465f3c72496d41009adc', 'tab': 'share', 'content': '<div class="markdown-text"><p>截止1 月 12日晚 22:00，有效参与人数共 252 人，抽取 5 名中奖者。\n恭喜以下中奖者🎉🎉🎉🎉🎉 gofromzero,MoeXian,yxcs,caoxiaoshuai1,langjy🎉🎉🎉🎉🎉\n请评论区留下联系方式。\n<img src="//static.cnodejs.org/Fvx9s9EjQk7IwNrAMO5_y7zJfrej" alt="image.png"></p>\n<p>---------------- 以下是原文 ----------------</p>\n<p>新书《Node.js开发实战》热卖，大获好评，感谢大家的支持，送几本书回馈给大家。</p>\n<p>赠书办法：</p>\n<ul>\n<li>只须在本贴留言即可。</li>\n<li>从回贴评论者中随机抽取中奖者，共计 5 本，每位中奖者 1 本。</li>\n<li>获赠名单公布在本帖，并在本贴下评论 @ 每位获赠的同学。</li>\n<li>截止时间 2019 年 1 月 12 日 22:00:00 （ UTC+8 ），以评论时间为准。</li>\n<li>由于本站不支持私信，请获奖同学在本帖回复联系方式，邮箱或者任何其它能联系到你的形式。</li>\n<li>开奖后 72 小时未能回复联系方式者视为放弃。</li>\n</ul>\n<p>试读样章：<a href="https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a>\n京东有售：<a href="https://item.jd.com/12460185.html">https://item.jd.com/12460185.html</a>\n<img src="//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh" alt="WechatIMG148 copy.jpg"></p>\n</div>', 'title': '送几本《Node.js开发实战》', 'last_reply_at': '2019-06-03T04:03:25.810Z', 'good': false, 'top': false, 'reply_count': 365, 'visit_count': 15947, 'create_at': '2019-01-04T04:11:13.570Z', 'author': { 'loginname': 'meikidd', 'avatar_url': 'https://avatars0.githubusercontent.com/u/376338?v=4&s=120' } }, { 'id': '5cf349f91fe902120f31b47a', 'author_id': '511350f6df9e9fcc58856443', 'tab': 'share', 'content': '<div class="markdown-text"><h2>一、前言</h2>\n<p>SOFARPC 是蚂蚁金服开源的一个高可扩展性、高性能、生产级的 Java RPC 框架，提供了丰富的模型抽象和可扩展接口，包括过滤器、路由、负载均衡等等，致力于简化应用之间的 RPC 调用，为应用提供方便透明、稳定高效的点对点远程服务调用方案。</p>\n<p>egg.js作为一个成熟的开源项目，清晰的定义了从配置、路由、扩展、中间件到控制器、定时任务等各个 Web 应用研发过程中一些最基础的概念，这样不同团队的开发者使用框架写出来的代码风格会更一致，接手老项目的上手成本也会更低。</p>\n<p>本文将简单介绍egg.js和sofa（Java）的相互作用，利用sofarpc的开源，展现一个初步的node.js RPC 解决方案。</p>\n<h2>二、RPC介绍</h2>\n<p>RPC  （Remote Procedure Call） 即 <strong>远程过程调用</strong>，就是像调用本地的函数一样去调用远程的函数。简单讲，就是本地调用的逻辑处理的过程放在的远程的机器上，而不是本地服务代理来处理。</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/5/31/16b0dcdc009880c4?w=636&amp;h=380&amp;f=jpeg&amp;s=26194" alt></p>\n<p>其实 HTTP 也可以实现远程调用的效果，那么 HTTP 与 RPC 到底是什么关系呢？有什么区别呢？</p>\n<p>经过了解，我们发现RPC 和 HTTP 其实是不在同一个层级的概念。</p>\n<h3>（一）RPC与HTTP区别</h3>\n<p><strong>RPC 通常所讲是一个框架</strong></p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/5/31/16b0dce8ae4c5c1c?w=1080&amp;h=229&amp;f=jpeg&amp;s=21388" alt></p>\n<p>结合上图，阿里对RPC开源RPC框架sofa优点的解读，我们了解到，RPC 也可以基于 HTTP 实现，如上图 GRPC ，就是 google 基于 HTTP2.0协议，RPC 也可以基于 TCP，Sockets实现。</p>\n<blockquote>\n<p>gRPC is a modern open source high performance RPC framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.</p>\n</blockquote>\n<p>而 HTTP(HyperText Transfer Protocol) 是基于 TCP 的实现的超文本传输协议，HTTP 是无状态协议；最初用于浏览器与服务器的通信，后来广泛用于各个服务间的通信。</p>\n<p><strong>RPC</strong>是<strong>远程过程调用</strong>，<strong>RPC框架</strong>可以的通信过程可以使用各种通信协议（如 <strong>HTTP</strong>，TCP以及各种自定义协议）实现。</p>\n<blockquote>\n<p>简单来说，成熟的rpc库相对http容器，更多的是封装了“服务发现”，“负载均衡”，“熔断降级”一类面向服务的高级特性，rpc框架是面向服务的更高级的封装。如果把一个http servlet容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。<br>\n所以为什么要用rpc调用？因为良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。</p>\n</blockquote>\n<p>这里可以关注知乎了解更多：<a href="https://www.zhihu.com/question/41609070/answer/191965937">既然有 HTTP 请求，为什么还要用 RPC 调用？</a></p>\n<h2>三、Nodejs有哪些比较流行的 RPC 框架?</h2>\n<ol>\n<li>grpc —— <a href="https://grpc.io">https://grpc.io</a>， 这个是国外比较流行的，有 google 背书，支持多语言，听说使用的公司也比较多，看上去是比较成熟的框架。</li>\n<li>sofa —— <a href="https://tech.antfin.com/sofa">https://tech.antfin.com/sofa</a> 这个是国内阿里开源的，目前阿里开源的 Eggjs 框架也开源了基于 sofa 的最佳实践。</li>\n<li>DUBBO —— 阿里开源的 java RPC 框架</li>\n</ol>\n<p><img src="https://user-gold-cdn.xitu.io/2019/5/31/16b0dd2370bbf394?w=1080&amp;h=685&amp;f=jpeg&amp;s=39769" alt></p>\n<h2>四、实践</h2>\n<p>基于“<a href="https://github.com/eggjs/egg-sofa-rpc/wiki/Eggjs-%E5%92%8C-SOFA-%E7%9A%84%E8%B7%A8%E8%AF%AD%E8%A8%80%E4%BA%92%E8%B0%83">Eggjs 和 SOFA 的跨语言互调</a>” 我们尝试了 Eggjs 下的 rpc 调用。</p>\n<h3>（一）zookeeper介绍</h3>\n<p>回到最初看 RPC 的原理， Client 端没有向 Server 端发起通信，而是需要Client Stub 和 Server Stub的桥接，完成 Client 和 Server 的通信；\n问题来了：</p>\n<ol>\n<li>Client Stub 和 Server Stub的桥接过程中如何找到对应的 Server？（<strong>服务地址储存</strong>）</li>\n<li>Server 接收到请求后，Client如何接收处理结果？（<strong>服务状态感知</strong>）</li>\n</ol>\n<p>Zookeeper 在此实现的框架上的作用就是解决上面两个问题，详情可参考：<a href="https://ketao1989.github.io/2016/12/10/rpc-theory-in-action/">https://ketao1989.github.io/2016/12/10/rpc-theory-in-action/</a></p>\n<p>对比起 http 服务里面，我们有一个配套的支撑基础组件叫做DNS，其根据域名找到某几个外网ip地址。然后，请求打到网站内部，一般首先到nginx群，nginx也会根据url规则找到配置好的一组ip地址，此外，nginx根据healthcheck来检查http服务是否可用。</p>\n<p>Zookeeper 在解决服务地址储存的所做事情就如DNS和 nginx一样。\n接下来主要从  “node服务 ——&gt; Java 服务“ 和 “ Java 服务 ——&gt; node服务” （使用sofa调用）来尝试</p>\n<h4>1. 配置</h4>\n<ul>\n<li>通过 <code>egg-init</code> 初始化项目脚手架，选择 simple 模板，接下来根据实际情况填写必要信息。</li>\n</ul>\n<pre class="prettyprint"><code>$ egg-init\n\n? Please select a boilerplate type (Use arrow keys)\n ──────────────\n❯ simple - Simple egg app boilerplate\n ts - Simple egg &amp;&amp; typescript app boilerplate\n empty - Empty egg app boilerplate\n plugin - egg plugin boilerplate\n framework - egg framework boilerplate   \n</code></pre><ul>\n<li>\n<p>进入生成好的项目目录，并安装依赖</p>\n</li>\n<li>\n<p>安装 <code>egg-sofa-rpc</code> 插件和 <code>egg-rpc-generator</code> 工具<br>\n<code>$ npm i egg-sofa-rpc --save</code><br>\n<code>$ npm i egg-rpc-generator --save-dev</code></p>\n</li>\n<li>\n<p>配置 <code>package.json</code> 的 scripts 节点，增加一个命令 <code>&quot;rpc&quot;: &quot;egg-rpc-generator&quot;</code></p>\n</li>\n</ul>\n<pre class="prettyprint language-"><code>{\n &quot;scripts&quot;: {\n   &quot;dev&quot;: &quot;egg-bin dev&quot;,\n   &quot;rpc&quot;: &quot;egg-rpc-generator&quot;\n }\n}\n</code></pre><p>补充下在阿里的文档没有提到的一点：必须在<code>package.json</code>文件最外层添加，这个<code>egg-int</code>工具并不会帮建这个。</p>\n<pre class="prettyprint"><code>&quot;egg&quot;: {\n   &quot;framework&quot;: &quot;sofa-node&quot;\n }\n</code></pre><ul>\n<li>配置 <code>config/plugin.js</code> 开启 <code>egg-sofa-rpc</code> 插件</li>\n</ul>\n<pre class="prettyprint"><code>&#x2F;&#x2F; config&#x2F;plugin.js\n\nexports.sofaRpc = {\nenable: true,\npackage: &#x27;egg-sofa-rpc&#x27;,\n};\n</code></pre><ul>\n<li>在<code>config/config.default.js</code> 配置<code>zookeeper</code></li>\n</ul>\n<pre class="prettyprint"><code>&#x2F;&#x2F; config&#x2F;config.default.js\n&#x27;use strict&#x27;;\n\nexports.sofaRpc = {\nregistry: {\n  address: &#x27;127.0.0.1:2181&#x27;, &#x2F;&#x2F; zk 地址指向本地 2181 端口\n},\n};\n</code></pre><h4>2.配置接口</h4>\n<p>ProtoService.proto</p>\n<pre class="prettyprint"><code>syntax = &quot;proto3&quot;;\n\npackage com.alipay.sofa.rpc.protobuf;\noption java_multiple_files = true; &#x2F;&#x2F; 可选\noption java_outer_classname = &quot;ProtoServiceModels&quot;; &#x2F;&#x2F; 可选\n\nservice ProtoService {\n    rpc echoObj (EchoRequest) returns (EchoResponse) {}\n}\n\nmessage EchoRequest {\n    string name = 1;\n    Group group = 2;\n}\n\nmessage EchoResponse {\n    int32 code = 1;\n    string message = 2;\n}\n\nenum Group {\n    A = 0;\n    B = 1;\n}\n</code></pre><p>上面这个 ProtoService.proto 文件定义了一个服务：实际上就是需要调用 Java 项目中com.alipay.sofa.rpc.protobuf.ProtoService，它有一个叫 echoObj 的方法，入口参数类型是 EchoRequest，返回值类型是 EchoResponse。</p>\n<p>该 Java 项目在此 <a href="https://github.com/eggjs/examples/tree/master/sofa-rpc">Eggjs RPC Example</a></p>\n<h3>（二）protobuf</h3>\n<h4>1.protobuf 是什么？</h4>\n<blockquote>\n<p>Protocol buffers 是一种语言中立，平台无关，可扩展的序列化数据的格式，可用于通信协议，数据存储等。\nProtocol buffers 在序列化数据方面，它是灵活的，高效的。相比于 XML 来说，Protocol buffers 更加小巧，更加快速，更加简单。一旦定义了要处理的数据的数据结构之后，就可以利用 Protocol buffers 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。\n<strong>它很适合做数据存储或 RPC数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。</strong></p>\n</blockquote>\n<p>protobuf在数据序列化的应用有以下几方面：</p>\n<ul>\n<li>在 config/proxy.js 中配置要调用的服务信息：</li>\n</ul>\n<pre class="prettyprint"><code>    &#x27;use strict&#x27;;\n    \n    module.exports = {\n      services: [{\n        appName: &#x27;sofarpc&#x27;,\n        api: {\n          ProtoService: &#x27;com.alipay.sofa.rpc.protobuf.ProtoService&#x27;,\n        },\n      }],\n    };\n</code></pre><ul>\n<li>在根目录下运行 npm run rpc，生成调用的 proxy 文：</li>\n</ul>\n<pre class="prettyprint"><code>    $ npm run rpc\n    &gt; rpc-demo@1.0.0 rpc &#x2F;egg-rpc-demo\n    &gt; egg-rpc-generator\n    [EggRpcGenerator] framework: &#x2F;egg-rpc-demo&#x2F;node_modules&#x2F;egg, baseDir: &#x2F;egg-rpc-demo\n    [ProtoRPCPlugin] found &quot;com.alipay.sofa.rpc.protobuf.ProtoService&quot; in proto file\n    [ProtoRPCPlugin] save all proto info into &quot;&#x2F;egg-rpc-demo&#x2F;run&#x2F;proto.json&quot;\n</code></pre><h4>2.Egg-sofa-generator</h4>\n<p>SOFARPC 插件是为 egg 提供调用和发布 RPC 服务的能力，该插件提供调用其他系统暴露的 SOFARPC 接口的能力。<br>\n<strong>那么这个插件如何应用在实际项目？</strong>\n实际上就是生成了app/proxy/ProtoService.js - 调用服务的代理文件。</p>\n<pre class="prettyprint"><code>    &#x2F;&#x2F; Don&#x27;t modified this file, it&#x27;s auto created by egg-rpc-generator\n    \n    &#x27;use strict&#x27;;\n    \n    const path = require(&#x27;path&#x27;);\n    \n    &#x2F;* eslint-disable *&#x2F;\n    &#x2F;* istanbul ignore next *&#x2F;\n    module.exports = app =&gt; {\n      const consumer = app.sofaRpcClient.createConsumer({\n        interfaceName: &#x27;com.alipay.sofa.rpc.protobuf.ProtoService&#x27;,\n        targetAppName: &#x27;sofarpc&#x27;,\n        version: &#x27;1.0&#x27;,\n        group: &#x27;SOFA&#x27;,\n        proxyName: &#x27;ProtoService&#x27;,\n        responseTimeout: 3000,\n      });\n    \n      if (!consumer) {\n        &#x2F;&#x2F; &#96;app.config[&#x27;sofarpc.rpc.service.enable&#x27;] = false&#96; will disable this consumer\n        return;\n      }\n    \n      app.beforeStart(async() =&gt; {\n        await consumer.ready();\n      });\n    \n      class ProtoService extends app.Proxy {\n        constructor(ctx) {\n          super(ctx, consumer);\n        }\n    \n        async echoObj(req) {\n          return await consumer.invoke(&#x27;echoObj&#x27;, [ req ], { \n            ctx: this.ctx,\n        codecType: &#x27;protobuf&#x27;,                        \n          });\n        }\n      }\n    \n      return ProtoService;\n    };\n    &#x2F;* eslint-enable *&#x2F;\n</code></pre><p><strong>如何调用该方法呢？</strong></p>\n<ul>\n<li>在路由里通过 ctx.proxy去调用</li>\n</ul>\n<pre class="prettyprint"><code>    &#x2F;&#x2F; app&#x2F;controller&#x2F;home.js\n    &#x27;use strict&#x27;;\n    \n    const Controller = require(&#x27;egg&#x27;).Controller;\n    \n    class HomeController extends Controller {\n      async index() {\n        const { ctx } = this;\n        const res = await ctx.proxy.protoService.echoObj({\n          name: &#x27;gxcsoccer&#x27;,\n        group: &#x27;A&#x27;,\n        });\n        ctx.body = res;\n      }\n    }\n    \n    module.exports = HomeController;\n</code></pre><pre class="prettyprint"><code>    npm run dev\n</code></pre><p>调试结果方面，调用接口之后如下图所示：</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/6/2/16b160ddc01c0473?w=996&amp;h=404&amp;f=jpeg&amp;s=114566" alt></p>\n<h2>五、小结</h2>\n<p>伴随 SOFARPC的开源，sofa-bolt-node 和 sofa-rpc-node 两个 Nodejs RPC 基础模块也逐步完善。本文主要将Eggjs 和 SOFA（Java）连通，尝试去提供EGG.js中RPC的一些引用。node社区不断完善，未来node.js在RPC中的尝试也可以越来越多。</p>\n<h2>六、参考文献</h2>\n<ul>\n<li><a href="https://www.yuque.com/egg/nodejs/cpn3uo">Eggjs 和 SOFA 的跨语言互调</a></li>\n<li><a href="https://ketao1989.github.io/2016/12/10/rpc-theory-in-action/">深入浅出RPC原理\n</a></li>\n<li><a href="https://zhuanlan.zhihu.com/p/28414262">分布式架构核心RPC原理</a></li>\n<li><a href="https://zhuanlan.zhihu.com/p/29857744">RPC原理解析</a></li>\n<li><a href="https://github.com/yuchenzhen/egg-rpc-demo">Demo示例</a></li>\n</ul>\n</div>', 'title': 'Node.js与RPC 的实践方案-Eggjs使用sofa-rpc-node模块', 'last_reply_at': '2019-06-03T03:32:58.918Z', 'good': false, 'top': false, 'reply_count': 2, 'visit_count': 315, 'create_at': '2019-06-02T04:00:57.647Z', 'author': { 'loginname': 'kalengo', 'avatar_url': 'https://avatars2.githubusercontent.com/u/8817810?v=4&s=120' } }, { 'id': '5cf3e03b95fcc914aa265590', 'author_id': '59eeb8e11bbf067d5c3fa7c6', 'tab': 'share', 'content': '<div class="markdown-text"><h2>1 基本概念</h2>\n<h3>1.1 CabloyJS是什么</h3>\n<h4>1.1.1 定义</h4>\n<blockquote>\n<p>CabloyJS是一款顶级NodeJS全栈业务开发框架</p>\n</blockquote>\n<h4>1.1.2 特点</h4>\n<ul>\n<li>CabloyJS是采用NodeJS进行全栈开发的最佳实践</li>\n<li>CabloyJS不重复造轮子，而是采用业界最新的开源技术，进行全栈开发的最佳组合</li>\n<li>CabloyJS前端采用VueJS + Framework7 + WebPack，后端采用KoaJS + EggJS，数据库采用MySQL</li>\n<li>CabloyJS时刻跟踪开源技术的最新成果，并持续优化，使整个框架时刻保持最佳状态</li>\n</ul>\n<h4>1.1.3 理念</h4>\n<blockquote>\n<p>既可快速开发，又可灵活定制</p>\n</blockquote>\n<p>为了实现此理念，CabloyJS内置开发了大量核心模块，使您可以在最短的时间内架构一个完整的Web项目。比如，当您新建一个Web项目时，就已经具备完整的用户登录与认证系统，也具有验证码功能，同时也具备<code>用户管理</code>、<code>角色管理</code>、<code>权限管理</code>等功能</p>\n<p>此外，这些内置模块提供了灵活的定制特性，您也可以开发全新的模块来替换内置模块，从而实现系统的定制化</p>\n<h3>1.2 CabloyJS核心解决什么问题</h3>\n<ol>\n<li>场景碎片化</li>\n<li>业务模块化</li>\n</ol>\n<h4>1.2.1 场景碎片化</h4>\n<h5>1) 先说说<code>Mobile场景</code></h5>\n<p>我们知道，随着智能机的日益普及，咱们开发人员所面对的需求场景与开发场景日益碎片化，如浏览器、IOS、Android，还有大量第三方平台：微信、企业微信、钉钉、Facebook、Slack等等</p>\n<p>随着智能设备性能越来越好，网速越来越快，针对如此众多的开发场景，采用H5开发必将是大势所趋。只需开发一套代码，就可以在以上所有智能设备中运行，不仅可以显著减少开发量，同时也可以显著提升开发效率，对开发团队和终端用户均是莫大的福利</p>\n<h5>2) 再来谈谈<code>PC场景</code></h5>\n<p>以上咱们说H5开发，只需开发一套代码，就可以在所有智能设备中运行。但是还有一个开发场景没有得到统一：那就是<code>PC场景</code></p>\n<p>由于屏幕显示尺寸的不同，<code>PC场景</code>和<code>Mobile场景</code>有着不同的操作风格。有些前端UI框架，采用“自适应”策略，为PC场景开发的页面，在Mobile场景下虽然也能查看和使用，但使用体验往往差强人意</p>\n<blockquote>\n<p>这也就是为什么有些前端框架总是成对出现的原因：如Element-UI和Mint-UI，如AntDesign和AntDesign-Mobile</p>\n</blockquote>\n<p>这也就意味着，当我们同时面对<code>PC场景</code>和<code>Mobile场景</code>时，仍然需要开发两套代码。在面对许多开发需求时，这些重复的工作量往往是难以接受的：</p>\n<ol>\n<li>比如，我们在企业微信或钉钉上开发一些H5业务应用，同时也希望这些应用也可以在PC端浏览器中运行</li>\n<li>比如，我们为微信公共号开发了一些H5业务应用，同时也希望这些应用也可以在PC端浏览器中运行。同时，还可以在同一架构下开发后台管理类功能，通过区别不同的登录用户、不同的使用场景，从而显示不同的前端页面</li>\n</ol>\n<h5>3) PC = MOBILE + PAD</h5>\n<p>CabloyJS前端采用Framework7框架，目前已同步升级到最新版Framework7 V4。CabloyJS在Framework7的基础上进行了巧妙的扩展，将PC端的页面切分为多个区域，实现了多个Mobile和PAD同时呈现在一个PC端的效果。换句话说，你买了一台Mac，就相对于买了多台IPhone和IPad，用多个虚拟的移动设备同时工作，即显著提升了工作效率，也提供了非常有趣的使用体验</p>\n<h5>4) 实际效果</h5>\n<blockquote>\n<p>有图有真相</p>\n</blockquote>\n<p><img src="https://admin.cabloy.com/api/a/file/file/download/e1ea0e10621b4aae92b440be440acc17.gif" alt="pc-mobile-layout"></p>\n<blockquote>\n<p>也可PC端体验</p>\n</blockquote>\n<p><a href="https://admin.cabloy.com">https://admin.cabloy.com</a></p>\n<blockquote>\n<p>也可手机扫描体验</p>\n</blockquote>\n<p><img src="https://admin.cabloy.com/api/a/file/file/download/8935ad82a31f45c8ab1427a07b5bce47.png" alt="cabloy-demo-qrcode"></p>\n<h5>5) 如何实现的</h5>\n<p>CabloyJS是模块化的全栈框架，为了实现<code>PC = MOBILE + PAD</code>的风格，内置了两个模块：<code>egg-born-module-a-layoutmobile</code>和<code>egg-born-module-a-layoutpc</code>。当前端框架加载完毕，会自动判断当前页面的宽度（称为breakpoint），如果小于800，使用Mobile布局，如果大于800，使用PC布局，而且breakpoint数值可以自定义</p>\n<p>此外，这两个布局模块本身也有许多参数可以自定义，甚至，您也可以开发自己的布局模块，替换掉内置的实现方式</p>\n<p>下面分别贴出两个布局模块的默认参数，相信您一看便知他们的用处</p>\n<p><code>egg-born-module-a-layoutmobile</code></p>\n<pre class="prettyprint language- javascript"><code>export default {\n  layout: {\n    login: &#x27;&#x2F;a&#x2F;login&#x2F;login&#x27;,\n    loginOnStart: true,\n    toolbar: {\n      tabbar: true, labels: true, bottom: true,\n    },\n    tabs: [\n      { name: &#x27;Home&#x27;, tabLinkActive: true, iconMaterial: &#x27;home&#x27;, url: &#x27;&#x2F;a&#x2F;base&#x2F;menu&#x2F;list&#x27; },\n      { name: &#x27;Atom&#x27;, tabLinkActive: false, iconMaterial: &#x27;group_work&#x27;, url: &#x27;&#x2F;a&#x2F;base&#x2F;atom&#x2F;list&#x27; },\n      { name: &#x27;Mine&#x27;, tabLinkActive: false, iconMaterial: &#x27;person&#x27;, url: &#x27;&#x2F;a&#x2F;user&#x2F;user&#x2F;mine&#x27; },\n    ],\n  },\n};\n</code></pre><p><code>egg-born-module-a-layoutpc</code></p>\n<pre class="prettyprint language- javascript"><code>export default {\n  layout: {\n    login: &#x27;&#x2F;a&#x2F;login&#x2F;login&#x27;,\n    loginOnStart: true,\n    header: {\n      buttons: [\n        { name: &#x27;Home&#x27;, iconMaterial: &#x27;dashboard&#x27;, url: &#x27;&#x2F;a&#x2F;base&#x2F;menu&#x2F;list&#x27;, target: &#x27;_dashboard&#x27; },\n        { name: &#x27;Atom&#x27;, iconMaterial: &#x27;group_work&#x27;, url: &#x27;&#x2F;a&#x2F;base&#x2F;atom&#x2F;list&#x27; },\n      ],\n      mine:\n        { name: &#x27;Mine&#x27;, iconMaterial: &#x27;person&#x27;, url: &#x27;&#x2F;a&#x2F;user&#x2F;user&#x2F;mine&#x27; },\n    },\n    size: {\n      small: 320,\n      top: 60,\n      spacing: 10,\n    },\n  },\n};\n</code></pre><h4>1.2.2 业务模块化</h4>\n<p>NodeJS的蓬勃发展，为前后端开发带来了更顺畅的体验，显著提升了开发效率。但仍有网友质疑NodeJS能否胜任大型Web应用的开发。大型Web应用的特点是随着业务的增长，需要开发大量的页面组件。面对这种场景，一般有两种解决方案：</p>\n<ol>\n<li>采用单页面的构建方式，缺点是产生的部署包很大</li>\n<li>采用页面异步加载方式，缺点是页面过于零散，需要频繁从后端获取JS资源</li>\n</ol>\n<p>CabloyJS实现了第三种解决方案：</p>\n<ol>\n<li>页面组件按业务需求归类，进行模块化，并且实现了模块的异步加载机制，从而弥合了前两种解决方案的缺点，完美满足大型Web应用业务持续增长的需求</li>\n</ol>\n<p>在CabloyJS中，一切业务开发皆以业务模块为单位。比如，我们要开发一个CMS建站工具，就新建一个业务模块，如已经实现的模块<code>egg-born-module-a-cms</code>。该CMS模块包含十多个Vue页面组件，在正式发布时，就会构建成一个JS包。在运行时，只需异步加载这一个JS包，就可以访问CMS模块中任何一个Vue页面组件了。</p>\n<p>因此，在一个大型的Web系统中，哪怕有数十甚至上百个业务模块，按CabloyJS的模块化策略进行代码组织和开发，既不会出现单一巨大的部署包，也不会出现大量碎片化的JS构建文件。</p>\n<p>CabloyJS的模块化系统还有如下显著的特点：</p>\n<h5>1) 零配置、零代码</h5>\n<p>也就是说，前面说到的模块化异步打包策略是已经精心调校好的系统核心特性，我们只需像平时一样开发Vue页面组件，在构建时系统会自动进行模块级别的打包，同时在运行时进行异步加载</p>\n<p>我们仍然以CMS模块为例，通过缩减的代码直观的看一下代码风格，如果想了解进一步的细节，可以直接查看对应的源码（下同，不再赘述）</p>\n<blockquote>\n<p>如何查看源码：进入项目的node_modules目录，查看<code>egg-born-</code>为前缀的模块源码即可</p>\n</blockquote>\n<p><code>egg-born-module-a-cms/src/module/a-cms/front/src/routes.js</code></p>\n<pre class="prettyprint language- javascript"><code>function load(name) {\n  return require(&#96;.&#x2F;pages&#x2F;${name}.vue&#96;).default;\n}\n\nexport default [\n  { path: &#x27;config&#x2F;list&#x27;, component: load(&#x27;config&#x2F;list&#x27;) },\n  { path: &#x27;config&#x2F;site&#x27;, component: load(&#x27;config&#x2F;site&#x27;) },\n  { path: &#x27;config&#x2F;siteBase&#x27;, component: load(&#x27;config&#x2F;siteBase&#x27;) },\n  { path: &#x27;config&#x2F;language&#x27;, component: load(&#x27;config&#x2F;language&#x27;) },\n  { path: &#x27;config&#x2F;languagePreview&#x27;, component: load(&#x27;config&#x2F;languagePreview&#x27;) },\n  { path: &#x27;category&#x2F;list&#x27;, component: load(&#x27;category&#x2F;list&#x27;) },\n  { path: &#x27;category&#x2F;edit&#x27;, component: load(&#x27;category&#x2F;edit&#x27;) },\n  { path: &#x27;category&#x2F;select&#x27;, component: load(&#x27;category&#x2F;select&#x27;) },\n  { path: &#x27;article&#x2F;contentEdit&#x27;, component: load(&#x27;article&#x2F;contentEdit&#x27;) },\n  { path: &#x27;article&#x2F;category&#x27;, component: load(&#x27;article&#x2F;category&#x27;) },\n  { path: &#x27;article&#x2F;list&#x27;, component: load(&#x27;article&#x2F;list&#x27;) },\n  { path: &#x27;article&#x2F;post&#x27;, component: load(&#x27;article&#x2F;post&#x27;) },\n  { path: &#x27;tag&#x2F;select&#x27;, component: load(&#x27;tag&#x2F;select&#x27;) },\n  { path: &#x27;block&#x2F;list&#x27;, component: load(&#x27;block&#x2F;list&#x27;) },\n  { path: &#x27;block&#x2F;item&#x27;, component: load(&#x27;block&#x2F;item&#x27;) },\n];\n</code></pre><p>可以看到，在前端页面路由的定义中，仍然是采用平时的同步加载写法</p>\n<p>关于模块的异步加载机制是由核心模块<code>egg-born-front</code>来完成的，参见源码<code>egg-born-front/src/base/module.js</code></p>\n<h5>2) 模块自洽、即插即用</h5>\n<p>每个业务模块都是自洽的整体，包含与本模块业务相关的前端代码和后端代码，而且采用前后端分离模式</p>\n<p><code>模块自洽</code>既有利于自身的<code>高度内聚</code>，也有利于整个系统的<code>充分解耦</code>。业务模块只需要考虑自身的逻辑实现，容易实现业务的<code>充分沉淀与分享</code>，达到<code>即插即用</code>的效果</p>\n<p>举一个例子：如果我们要开发文件上传功能，当我们在网上找到合适的上传组件之后，在自己的项目中使用时，仍然需要开发大量对接代码。也就是说，在网上找到的上传组件没有实现充分的沉淀，不是自洽的，也就不能实现便利的分享，达到<code>即插即用</code>的效果</p>\n<p>而CabloyJS内置的的文件上传模块<code>egg-born-module-a-file</code>就实现了功能的充分沉淀。为什么呢？因为业务模块本身就包含前端代码和后端代码，能够施展的空间很大，可以充分细化上传逻辑</p>\n<p>因此，在CabloyJS中要调用文件上传功能，就会变得极其便捷。以CMS模块为例，上传图片并取得图片URL，只需短短20行代码</p>\n<p><code>egg-born-module-a-cms/src/module/a-cms/front/src/pages/article/contentEdit.vue</code></p>\n<pre class="prettyprint language- javascript"><code>...\n    onUpload(mode, atomId) {\n      return new Promise((resolve, reject) =&gt; {\n        this.$view.navigate(&#x27;&#x2F;a&#x2F;file&#x2F;file&#x2F;upload&#x27;, {\n          context: {\n            params: {\n              mode,\n              atomId,\n            },\n            callback: (code, data) =&gt; {\n              if (code === 200) {\n                resolve({ text: data.realName, addr: data.downloadUrl });\n              }\n              if (code === false) {\n                reject();\n              }\n            },\n          },\n        });\n      });\n    },\n...\n</code></pre><h5>3) 模块隔离</h5>\n<p>在大型Web项目中，不可避免的要考虑各类资源、各种变量、各个实体之间命名的冲突问题。针对这个问题，不同的开发团队大都会规范各类实体的命名规范。随着项目的扩充，这种命名规范仍然会变得很庞杂。如果我们面对的是一个开放的系统，使用的是来自不同团队开发的模块，所面临的命名冲突的风险就会越发严重</p>\n<p>CabloyJS使用了一个巧妙的设计，一劳永逸解决了命名冲突的隐患。在CabloyJS中，业务模块采用如下命名规范：</p>\n<pre class="prettyprint"><code>egg-born-module-{providerId}-{moduleName}\n</code></pre><ul>\n<li><code>providerId</code>: 开发者Id，强烈建议采用Github的Username，从而确保贡献到社区的模块不会冲突</li>\n<li><code>moduleName</code>: 模块名称</li>\n</ul>\n<p>由于<code>模块自洽</code>的设计机制，我们只需要解决模块命名的唯一性问题，在进行模块开发时就不会再被命名冲突的困扰所纠缠了</p>\n<p>比如，CMS模块提供了一个前端页面路由<code>config/list</code>。很显然，如此简短的路径，在其他业务模块中出现的概率非常高。但在CabloyJS中，如此命名就不会产出冲突。在CMS模块内部进行页面跳转时，可以直接使用<code>config/list</code>，这称之为<code>相对路径</code>引用。但是，如果其他业务模块也想跳转至此页面就使用<code>/a/cms/config/list</code>，这称之为<code>绝对路径</code>引用</p>\n<p>再比如，前面的例子我们要调用上传文件页面，就是采用<code>绝对路径</code>：<code>/a/file/file/upload</code></p>\n<p><code>模块隔离</code>是业务模块的核心特性。这是因为，模块前端和后端有大量实体都需要进行这种隔离。CabloyJS从系统层面完成了这种隔离的机制，从而使得我们在实际的模块业务开发时可以变得轻松、便捷。</p>\n<blockquote>\n<p>模块前端隔离机制</p>\n</blockquote>\n<p>模块前端的隔离机制由模块<code>egg-born-front</code>来完成，实现了如下实体的隔离：</p>\n<ol>\n<li>前端页面组件路由：<a href="https://cabloy.com/zh-cn/articles/7503a4d34b83409ba6477135fa840736.html">参见</a></li>\n<li>前端参数配置：<a href="https://cabloy.com/zh-cn/articles/3952948bf69e4fc2ae6930d1fc58ba0f.html">参见</a></li>\n<li>前端状态管理：<a href="https://cabloy.com/zh-cn/articles/096584b6a8174fea9039d745a812bea7.html">参见</a></li>\n<li>前端国际化：<a href="https://cabloy.com/zh-cn/articles/1c7c9cf3861744c2a63ae134076c652f.html">参见</a></li>\n</ol>\n<blockquote>\n<p>模块后端隔离机制</p>\n</blockquote>\n<p>模块后端的隔离机制由模块<code>egg-born-backend</code>来完成，实现了如下实体的隔离：</p>\n<ol>\n<li>后端API接口路由：<a href="https://cabloy.com/zh-cn/articles/515720864cc14d6b94c3194283272bb6.html">参见</a></li>\n<li>后端Service：<a href="https://cabloy.com/zh-cn/articles/fbe1d2789f1343fdb210e3acaac2097f.html">参见</a></li>\n</ol>\n<blockquote>\n<p>后端Service隔离，不仅是解决命名冲突的需要，更是性能提升方面重要的考量。</p>\n</blockquote>\n<blockquote>\n<p>比如有50个业务模块，每个模块有20个Service，这样全局就有1000个Service。 在EggJS中，这1000个Service需要一次性预加载以便供Controller代码调用。CabloyJS就在EggJS的基础上做了隔离处理，如果是模块A的Controller，只需要预加载模块A的20个Service，供模块A的Controller调用。这样，就实现了一举两得：不仅命名隔离，而且性能提升，从而满足大型Web系统开发的需求</p>\n</blockquote>\n<ol>\n<li>后端Model：<a href="https://cabloy.com/zh-cn/articles/d33153578d564a79a7ed1176944d0541.html">参见</a></li>\n</ol>\n<blockquote>\n<p>后端Model是CabloyJS实现的访问数据实体的便捷工具，在Model的定义和使用上，都比Sequelize简洁、高效</p>\n</blockquote>\n<blockquote>\n<p>与后端Service一样，后端Model也实现了命名隔离，同时也只能被模块自身的Controller和Service调用</p>\n</blockquote>\n<ol>\n<li>后端参数配置：<a href="https://cabloy.com/zh-cn/articles/13e14810cb124ac2908220caf4f29ac4.html">参见</a></li>\n<li>后端Error处理：<a href="https://cabloy.com/zh-cn/articles/b81df4d4ed4d4428b286d41a8d7bbca3.html">参见</a></li>\n<li>后端国际化：<a href="https://cabloy.com/zh-cn/articles/f6d5a48f10dc40d3b8aed7862c23570b.html">参见</a></li>\n</ol>\n<h5>4) 快速的前端构建</h5>\n<p>CabloyJS采用WebPack进行项目的前端构建。由于CabloyJS项目是由一系列业务模块组成的，因此，可以把模块代码提前预编译，从而在构建整个项目的前端时就可以显著提升构建速度</p>\n<p>经实践，如果一个项目包含40个业务模块，如果按照普通的构建模式需要70秒构建完成。而采用预编译的机制，则只需要20秒即可完成。这对于开发大型Web项目具有显著的工程意义</p>\n<h5>5) 保护商业代码</h5>\n<p>CabloyJS中的业务模块，不仅前端代码可以构建，后端代码也可以用WebPack进行构建。后端代码在构建时，也可以指定是否丑化，这种机制可以满足<code>保护商业代码</code>的需求</p>\n<blockquote>\n<p>CabloyJS后端的基础是EggJS，是如何做到可以编译构建的呢？</p>\n</blockquote>\n<p>CabloyJS后端在EggJS的基础上进行了扩展，每个业务模块都有一个入口文件main.js，通过main.js串联后端所有JS代码，因此可以轻松实现编译构建</p>\n<h3>1.3 CabloyJS的开发历程</h3>\n<h4>1.3.1 两阶段</h4>\n<p>CabloyJS从2016年启动开发，主要历经两个开发阶段：</p>\n<h5>1） 第一阶段：EggBornJS</h5>\n<p>EggBornJS关注的核心就是实现一套完整的以业务模块为核心的全栈开发框架</p>\n<p>比如模块<code>egg-born-front</code>是框架前端的核心模块，模块<code>egg-born-backend</code>是框架后端的核心模块，模块<code>egg-born</code>是框架的命令行工具，用于创建项目骨架</p>\n<p>这也是为什么所有业务模块都是以<code>egg-born-module-</code>为命名前缀的原因</p>\n<h5>2） 第二阶段：CabloyJS</h5>\n<p>EggBornJS只是一个基础的全栈开发框架，如果要进行业务开发，还需要考虑许多与业务相关的支撑特性，如：<code>用户管理</code>、<code>角色管理</code>、<code>权限管理</code>、<code>菜单管理</code>、<code>参数设置管理</code>、<code>表单验证</code>、<code>登录机制</code>，等等。特别是在前后端分离的场景下，对<code>权限管理</code>的要求就提升到一个更高的水平</p>\n<p>CabloyJS在EggBornJS的基础上，提供了一套核心业务模块，从而实现了一系列业务支撑特性，并将这些特性进行有机的组合，形成完整而灵活的上层生态架构，从而支持具体的业务开发进程</p>\n<p>换句话说，从实质上看，CabloyJS是一组核心业务模块的组合，从形式上看，CabloyJS是一组模块依赖项。且看CabloyJS的package.json文件：</p>\n<p><code>cabloy/package.json</code></p>\n<pre class="prettyprint language- javascript"><code>{\n  &quot;name&quot;: &quot;cabloy&quot;,\n  &quot;version&quot;: &quot;2.1.2&quot;,\n  &quot;description&quot;: &quot;The Ultimate Javascript Full Stack Framework&quot;,\n  ...\n  &quot;author&quot;: &quot;zhennann&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  ...\n  &quot;dependencies&quot;: {\n    &quot;egg-born-front&quot;: &quot;^4.1.0&quot;,\n    &quot;egg-born-backend&quot;: &quot;^2.1.0&quot;,\n    &quot;egg-born-bin&quot;: &quot;^1.2.0&quot;,\n    &quot;egg-born-scripts&quot;: &quot;^1.1.0&quot;,\n    &quot;egg-born-module-a-version&quot;: &quot;^2.2.2&quot;,\n    &quot;egg-born-module-a-authgithub&quot;: &quot;^2.0.3&quot;,\n    &quot;egg-born-module-a-authsimple&quot;: &quot;^2.0.3&quot;,\n    &quot;egg-born-module-a-base-sync&quot;: &quot;^2.0.10&quot;,\n    &quot;egg-born-module-a-baseadmin&quot;: &quot;^2.0.3&quot;,\n    &quot;egg-born-module-a-cache&quot;: &quot;^2.0.3&quot;,\n    &quot;egg-born-module-a-captcha&quot;: &quot;^2.0.4&quot;,\n    &quot;egg-born-module-a-captchasimple&quot;: &quot;^2.0.3&quot;,\n    &quot;egg-born-module-a-components-sync&quot;: &quot;^2.0.5&quot;,\n    &quot;egg-born-module-a-event&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-file&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-hook&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-index&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-instance&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-layoutmobile&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-layoutpc&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-login&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-mail&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-markdownstyle&quot;: &quot;^2.0.3&quot;,\n    &quot;egg-born-module-a-mavoneditor&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-progress&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-sequence&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-settings&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-status&quot;: &quot;^2.0.2&quot;,\n    &quot;egg-born-module-a-user&quot;: &quot;^2.0.3&quot;,\n    &quot;egg-born-module-a-validation&quot;: &quot;^2.0.4&quot;,\n    &quot;egg-born-module-test-cook&quot;: &quot;^2.0.2&quot;\n  }\n}\n</code></pre><blockquote>\n<p>相信您通过这些核心模块的名称，就已经猜到这些模块的用处了</p>\n</blockquote>\n<h4>1.3.2 整体架构图</h4>\n<p>根据前面两阶段的分析，我们就可以勾勒出框架的整体架构图</p>\n<p><img src="https://admin.cabloy.com/api/a/file/file/download/46cb08112dad40ca95fa506023da9b85.png" alt="cabloy"></p>\n<p>这种架构，让整个体系变得层次分明，也让实际的Web项目的源代码文件组织结构变得非常简洁直观。大量的架构细节都封装在EggBornJS中，而我们的Web项目只需要引用一个CabloyJS即可，CabloyJS负责引用架构中其他核心模块</p>\n<p>这种架构，也让实际的Web项目的升级变得更加容易，具体如下：</p>\n<pre class="prettyprint language- bash"><code>1) 删除现有模块依赖项\n$ rm -rf node_modules\n2) 如果有此文件，建议删除\n$ rm -rf package-lock.json \n3) 重新安装所有模块依赖项\n$ npm i\n</code></pre><h4>1.3.3 意义</h4>\n<blockquote>\n<p>有了EggBornJS，从此可复用的不仅仅是组件，还有业务模块</p>\n</blockquote>\n<blockquote>\n<p>有了CabloyJS，您就可以快速开发各类业务应用</p>\n</blockquote>\n<h2>2 数据版本与开发流程</h2>\n<p>业务模块必然要处理数据并且存储数据，当然也不可避免会出现数据架构的变动，比如新增表、新增字段、删除字段、调整旧数据，等等</p>\n<p>CabloyJS通过巧妙的数据版本控制，可以让业务模块在不断的迭代过程中，无缝的完成模块升级和数据升级</p>\n<p>在数据版本的基础上，再配合一套开发流程，从而不论是在开发环境还是生产坏境，都能有顺畅的开发与使用体验</p>\n<h3>2.1 数据版本</h3>\n<h4>2.1.1 数据版本定义</h4>\n<p>可以通过package.json指定业务模块的数据版本，以模块<code>egg-born-module-test-cook</code>为例</p>\n<p><code>egg-born-module-test-cook/package.json</code></p>\n<pre class="prettyprint language- javascript"><code>{\n  &quot;name&quot;: &quot;egg-born-module-test-cook&quot;,\n  &quot;version&quot;: &quot;2.0.2&quot;,\n  &quot;eggBornModule&quot;: {\n    &quot;fileVersion&quot;: 1,\n    &quot;dependencies&quot;: {\n      &quot;a-base&quot;: &quot;1.0.0&quot;\n    }\n  },\n  ...\n}\n</code></pre><p>模块当前的数据版本<code>fileVersion</code>为<code>1</code>。当这个模块正式发布出去之后，为<code>1</code>的数据版本就处于封闭状态。当有新的迭代，需要改变模块的数据架构时，就需要将<code>fileVersion</code>递增为<code>2</code>。以此类推，从而完成模块数据架构的自动无缝升级</p>\n<h4>2.1.1 数据版本升级</h4>\n<p>当CabloyJS后端服务在启动时，会自动检测每个业务模块的数据版本，当存在数据版本变更时，就会自动调用业务模块的升级代码，从而完成自动升级。仍以模块<code>egg-born-module-test-cook</code>为例，其数据版本升级代码如下：</p>\n<p><code>egg-born-module-test-cook/backend/src/service/version.js</code></p>\n<pre class="prettyprint language- javascript"><code>...\n    async update(options) {\n      if (options.version === 1) {\n        let sql = &#96;\n          CREATE TABLE testCook (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT &#x27;0&#x27;,\n            iid int(11) DEFAULT &#x27;0&#x27;,\n            atomId int(11) DEFAULT &#x27;0&#x27;,\n            cookCount int(11) DEFAULT &#x27;0&#x27;,\n            cookTypeId int(11) DEFAULT &#x27;0&#x27;,\n            PRIMARY KEY (id)\n          )\n        &#96;;\n        await this.ctx.model.query(sql);\n\n        sql = &#96;\n          CREATE TABLE testCookType (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT &#x27;0&#x27;,\n            iid int(11) DEFAULT &#x27;0&#x27;,\n            name varchar(255) DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        &#96;;\n        await this.ctx.model.query(sql);\n\n        sql = &#96;\n          CREATE VIEW testCookView as\n            select a.*,b.name as cookTypeName from testCook a\n              left join testCookType b on a.cookTypeId=b.id\n        &#96;;\n        await this.ctx.model.query(sql);\n\n        sql = &#96;\n          CREATE TABLE testCookPublic (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT &#x27;0&#x27;,\n            iid int(11) DEFAULT &#x27;0&#x27;,\n            atomId int(11) DEFAULT &#x27;0&#x27;,\n            PRIMARY KEY (id)\n          )\n        &#96;;\n        await this.ctx.model.query(sql);\n      }\n    }\n...\n</code></pre><p>当数据版本变更时，CabloyJS后端调用方法<code>update</code>，通过判断属性<code>options.version</code>的值，进行对应版本的数据架构变更</p>\n<h3>2.2 开发流程</h3>\n<h4>2.2.1 背景</h4>\n<p>那么问题来了？在模块开发阶段，如果需要变更数据架构怎么办呢？因为模块还没有正式发布，所以，不需要锁定数据版本。也就是说，如果当前数据版本<code>fileVersion</code>是<code>1</code>，那么在正式发布之前，不论进行多少次数据架构变更，<code>fileVersion</code>仍是<code>1</code></p>\n<p>一方面，我们肯定要修改方法<code>update</code>，加入架构变更的代码逻辑，比如添加表、添加字段等等</p>\n<p>另一方面，我们还要修改当前测试数据库中的数据架构。因为<code>fileVersion</code>是没有变化的，所以当重启CabloyJS后端服务时，方法<code>update</code>并不会再次执行</p>\n<p>针对这种情况，首先想到的是手工修改测试数据库中的数据架构。而CabloyJS提供了更优雅的机制</p>\n<h4>2.2.2 运行环境</h4>\n<p>我们知道EggJS提供了三个运行环境：<code>测试环境</code>、<code>开发环境</code>、<code>生产环境</code>。CabloyJS在EggJS的基础上，对这三个运行环境赋予了进一步的意义</p>\n<h5>1) 测试环境</h5>\n<ul>\n<li>测试环境的参数配置如下</li>\n</ul>\n<p><code>{项目目录}/src/backend/config/config.unittest.js</code></p>\n<pre class="prettyprint language- javascript"><code>module.exports = appInfo =&gt; {\n  const config = {};\n  ...\n  &#x2F;&#x2F; mysql\n  config.mysql = {\n    clients: {\n      &#x2F;&#x2F; donnot change the name\n      __ebdb: {\n        host: &#x27;127.0.0.1&#x27;,\n        port: &#x27;3306&#x27;,\n        user: &#x27;root&#x27;,\n        password: &#x27;&#x27;,\n        database: &#x27;sys&#x27;, &#x2F;&#x2F; donnot change the name\n      },\n    },\n  };\n  ...\n  return config;\n};\n</code></pre><ul>\n<li>命令行如下：</li>\n</ul>\n<pre class="prettyprint language- bash"><code>$ npm run test:backend\n</code></pre><p>由于我们将<code>测试环境</code>的数据库名称设为<code>sys</code>，那么CabloyJS就会自动删除旧的测试数据库，建立新的数据库。因为是重新创建数据库，那么也就意味着<code>fileVersion</code>由<code>0</code>升级为<code>1</code>，从而触发方法<code>update</code>的执行，进而自动完成数据架构的升级</p>\n<h5>2) 开发环境</h5>\n<ul>\n<li>开发环境的参数配置如下</li>\n</ul>\n<p><code>{项目目录}/src/backend/config/config.local.js</code></p>\n<pre class="prettyprint language- javascript"><code>module.exports = appInfo =&gt; {\n  const config = {};\n  ...\n  &#x2F;&#x2F; mysql\n  config.mysql = {\n    clients: {\n      &#x2F;&#x2F; donnot change the name\n      __ebdb: {\n        host: &#x27;127.0.0.1&#x27;,\n        port: &#x27;3306&#x27;,\n        user: &#x27;root&#x27;,\n        password: &#x27;&#x27;,\n        database: &#x27;sys&#x27;, &#x2F;&#x2F; recommended\n      },\n    },\n  };\n  ...\n  return config;\n};\n</code></pre><ul>\n<li>命令行如下：</li>\n</ul>\n<pre class="prettyprint language- bash"><code>$ npm run dev:backend\n</code></pre><p>虽然我们也将<code>开发环境</code>的数据库名称设为<code>sys</code>，但是CabloyJS会自动寻找最新创建的测试数据库，然后一直使用它</p>\n<h5>3) 生产环境</h5>\n<ul>\n<li>生产环境的参数配置如下</li>\n</ul>\n<p><code>{项目目录}/src/backend/config/config.prod.js</code></p>\n<pre class="prettyprint language- javascript"><code>module.exports = appInfo =&gt; {\n  const config = {};\n  ...\n  &#x2F;&#x2F; mysql\n  config.mysql = {\n    clients: {\n      &#x2F;&#x2F; donnot change the name\n      __ebdb: {\n        host: &#x27;127.0.0.1&#x27;,\n        port: &#x27;3306&#x27;,\n        user: &#x27;root&#x27;,\n        password: &#x27;&#x27;,\n        database: &#x27;{实际数据库名}&#x27;,\n      },\n    },\n  };\n  ...\n  return config;\n};\n</code></pre><ul>\n<li>命令行如下：</li>\n</ul>\n<pre class="prettyprint language- bash"><code>$ npm run start:backend\n</code></pre><p>因为<code>生产环境</code>存储的都是实际业务数据，所以在<code>生产环境</code>就要设置实际的数据库名称了</p>\n<h4>2.2.3 开发流程的最佳实践</h4>\n<p>根据前面<code>数据版本</code>和<code>运行环境</code>的分析，我们就可以规划出一套关于<code>开发流程</code>的最佳实践：</p>\n<ol>\n<li>当项目创建后，先执行一次<code>npm run test:backend</code>，用于自动创建一个测试数据库</li>\n<li>在进行常规开发时，执行<code>npm run dev:backend</code>来启动项目后端服务，用于调试</li>\n<li>如果模块数据版本需要变更，在修改完属性<code>fileVersion</code>和方法<code>update</code>之后，再一次执行<code>npm run test:backend</code>，从而重建一个新的测试数据库</li>\n<li>当项目需要在生产环境运行时，则运行<code>npm run start:backend</code>来启动后端服务</li>\n</ol>\n<h2>3 特性鸟瞰</h2>\n<h3>3.1 多实例与多域名</h3>\n<p>CabloyJS通过<code>多实例</code>的概念来支持<code>多域名站点</code>的开发。启动一个服务，可以支持多个实例运行。实例共享数据表架构，但运行中产生的数据是相互隔离的</p>\n<p>这有什么好处呢？比如您用CabloyJS开发了一款CRM的SAAS服务，那么只需开发并运行一个服务，就可以同时服务多个不同的客户。每个客户一个实例，用一个单独的域名进行区分即可。</p>\n<p>再比如，要想开发一款基于微信公共号的营销平台，提供给不同的客户使用，<code>多实例与多域名</code>是最自然、最有效的架构设计。</p>\n<p>具体信息，请<a href="https://cabloy.com/zh-cn/articles/44e45b3928ca4c6cb63809558145e000.html">参见</a></p>\n<h3>3.2 数据库事务</h3>\n<h4>3.2.1 EggJS事务处理方式</h4>\n<pre class="prettyprint language- javascript"><code>const conn = await app.mysql.beginTransaction(); &#x2F;&#x2F; 初始化事务\n\ntry {\n  await conn.insert(table, row1);  &#x2F;&#x2F; 第一步操作\n  await conn.update(table, row2);  &#x2F;&#x2F; 第二步操作\n  await conn.commit(); &#x2F;&#x2F; 提交事务\n} catch (err) {\n  &#x2F;&#x2F; error, rollback\n  await conn.rollback(); &#x2F;&#x2F; 一定记得捕获异常后回滚事务！！\n  throw err;\n}\n</code></pre><h4>3.2.2 CabloyJS事务处理方式</h4>\n<p>CabloyJS在EggJS的基础上进行了扩展，使得<code>数据库事务处理</code>变得更加自然，甚至可以说是<code>无痛处理</code></p>\n<p>在CabloyJS中，实际的代码逻辑不用考虑<code>数据库事务</code>，如果哪个后端API路由需要启用<code>数据库事务</code>，直接在API路由上声明一个中间件<code>transaction</code>即可，以模块<code>egg-born-module-test-cook</code>为例</p>\n<p><code>egg-born-module-test-cook/backend/src/routes.js</code></p>\n<pre class="prettyprint language- javascript"><code>...\n  { method: &#x27;get&#x27;, path: &#x27;test&#x2F;echo&#x2F;:id&#x27;, controller: test, action: &#x27;echo&#x27;, middlewares: &#x27;transaction&#x27; },\n...\n</code></pre><h3>3.3 完美的用户与身份认证分离体系</h3>\n<h4>3.3.1 通用的身份认证</h4>\n<p>CabloyJS把<code>用户系统</code>与<code>身份认证系统</code>完全分离，有如下好处：</p>\n<ol>\n<li>支持众多身份认证机制：用户名/密码认证、手机认证、第三方认证（Github、微信）等等</li>\n<li>可完全定制登录页面，自由组合各种身份认证机制</li>\n<li>网站用户也可以自由添加不同的身份认证机制，也可以自由的删除</li>\n</ol>\n<blockquote>\n<p>比如，<code>用户A</code>先通过<code>用户名/密码</code>注册的身份，以后还可以添加<code>Github、微信</code>等认证方式</p>\n</blockquote>\n<blockquote>\n<p>比如，<code>用户B</code>先通过<code>Github</code>注册的身份，以后还可以添加<code>用户名/密码</code>等认证方式</p>\n</blockquote>\n<h4>3.3.2 通用的验证码机制</h4>\n<p>CabloyJS把验证码机制抽象了出来，并且提供了一个缺省的验证码模块<code>egg-born-module-a-captchasimple</code>，您也可以按统一规范开发自己的验证码模块，然后挂接到系统中</p>\n<h4>3.3.3 通用的邮件发送机制</h4>\n<p>CabloyJS也实现了通用的邮件发送功能，基于成熟的<code>nodemailer</code>。由于<code>nodemailer</code>内置了一个测试服务器，因此，在开发环境中，不需要真实的邮件发送账号，也可以进行系统的测试与调试</p>\n<h3>3.4 模块编译与发布</h3>\n<p>前面我们谈到CabloyJS中的业务模块是自洽的，可以单独编译打包，既可以显著提升整体项目打包的效率，也可以满足<code>保护商业代码</code>的需求。这里我们看看模块编译与发布的基本操作</p>\n<h4>3.4.1 如何编译模块</h4>\n<pre class="prettyprint language- bash"><code>$ cd &#x2F;path&#x2F;to&#x2F;module\n  1) 构建前端代码\n$ npm run build:front\n  2) 构建后端代码\n$ npm run build:backend\n</code></pre><h4>3.4.2 编译参数</h4>\n<ol>\n<li>前端编译：为了提升整体项目打包的效率，模块前端编译默认开启丑化处理</li>\n<li>后端编译：默认关闭丑化处理，可通过修改编译参数开启丑化选项</li>\n</ol>\n<blockquote>\n<p>后端为什么默认关闭丑化选项呢？</p>\n</blockquote>\n<blockquote>\n<p>答：CabloyJS所有内置的核心模块都是关闭丑化选项的，这样便于您直观的调试整个系统的源代码，也可以很容易走进CabloyJS，发现一些更有趣的架构设计</p>\n</blockquote>\n<p><code>{模块目录}/build/config.js</code></p>\n<pre class="prettyprint language- javascript"><code>module.exports = {\n  productionSourceMap: true,\n  uglify: false,\n};\n</code></pre><h4>3.4.3 模块发布</h4>\n<p>当项目中的模块代码稳定后，可以将模块公开发布，贡献到开源社区。也可以在公司内部建立npm私有仓库，然后把模块发布到私有仓库，形成公司资产，便于重复使用</p>\n<pre class="prettyprint language- bash"><code>$ cd &#x2F;path&#x2F;to&#x2F;module\n$ npm publish\n</code></pre><h2>4 业务开发</h2>\n<p>到目前为止，实话说，前面谈到的概念大多属于EggBornJS的层面。CabloyJS在EggBornJS的基础上，开发了大量核心业务模块，从而支持业务层面的快速开发。下面我们就介绍一些基本概念</p>\n<h3>4.1 原子的概念</h3>\n<h4>4.1.1 原子是什么</h4>\n<p>原子是CabloyJS最基本的要素，如文章、公告、请假单，等等</p>\n<p>为什么叫原子？在化学反应中，原子是最基本的粒子。在CabloyJS中，通过原子的组合，就可以实现任何想要的功能，如CMS、OA、CRM、ERP，等等</p>\n<p>比如，您所看到的这篇文章就是一个原子</p>\n<h4>4.1.2 原子的意义</h4>\n<p>正由于从各种<code>业务模型</code>中抽象出来一个通用的<code>原子</code>概念，因而，CabloyJS为原子实现了许多通用的特性和功能，从而可以便利的为各类实际业务赋能</p>\n<p>比如，模块CMS中的文章可以<code>发表评论</code>，可以<code>点赞</code>，支持<code>草稿</code>、<code>搜索</code>功能。这些都是CabloyJS核心模块<code>egg-born-module-a-base-sync</code>提供的通用特性与功能。只要新建一个原子类型，这些原子都会被赋能</p>\n<blockquote>\n<p>这就是<code>抽象</code>的力量</p>\n</blockquote>\n<h4>4.1.3 统一存储</h4>\n<p>所有原子数据都会有一些相同的字段属性，也会有与业务相关的字段属性。相同的字段都统一存储到数据表<code>aAtom</code>中，与业务相关的字段存储在具体的<code>业务表</code>中，<code>aAtom</code>与<code>业务表</code>是一对一的关系</p>\n<p>这种存储机制体现了<code>共性</code>与<code>差异性</code>的有机统一，有如下好处：</p>\n<ol>\n<li>可统一配置<code>数据权限</code></li>\n<li>可统一支持<code>增删改查</code>等操作</li>\n<li>可统一支持<code>星标、标签、草稿、搜索</code>等操作</li>\n</ol>\n<p>关于<code>原子</code>的更多信息，请<a href="https://cabloy.com/zh-cn/articles/4638e7eef869447bbf2d439007010db7.html">参见</a></p>\n<h3>4.2 角色体系</h3>\n<p><code>角色</code>是面向业务系统开发最核心的功能之一，CabloyJS提供了既简洁又灵活的<code>角色体系</code></p>\n<h4>4.2.1 角色模型</h4>\n<p>CabloyJS的角色体系不同于网上流行的<code>RBAC模型</code></p>\n<blockquote>\n<p><code>RBAC模型</code>没有解决业务开发中<code>资源范围授权</code>的问题。比如，<code>Mike</code>是软件部的员工，只能查看自己的日志；<code>Jone</code>是软件部经理，可以查看本部门的日志；<code>Jimmy</code>是企业负责人，可以查看整个企业的日志</p>\n</blockquote>\n<blockquote>\n<p><code>RBAC模型</code>概念复杂，在实际应用中，又往往引入新的概念（用户组、部门、岗位等），使得角色体系<code>叠床架屋</code>，理解困难，维护繁琐</p>\n</blockquote>\n<h4>4.2.2 概念辨析</h4>\n<p>涉及到角色体系，往往会有这些概念：<code>用户</code>、<code>用户组</code>、<code>角色</code>、<code>部门</code>、<code>岗位</code>、<code>授权对象</code>等等</p>\n<p>而CabloyJS设计的角色体系只有<code>用户</code>、<code>角色</code>、<code>授权对象</code>等概念，概念精简，层次清晰，灵活高效，既便于理解，又便于维护</p>\n<h5>1) 部门即角色</h5>\n<p><code>部门</code>从本质上来说，其实就是角色，如：<code>软件部</code>、<code>财务部</code>等等</p>\n<h5>2) 岗位即角色</h5>\n<p><code>岗位</code>从本质上来说，其实也就是角色，如：<code>软件部经理</code>、<code>软件部设计岗</code>、<code>软件部开发岗</code>等等</p>\n<h5>3) 资源范围即角色</h5>\n<p><code>资源范围</code>也是角色。如：<code>Jone</code>是软件部经理，可以查看<code>软件部</code>的日志。其中，<code>软件部</code>就是<code>资源范围</code></p>\n<h4>4.2.3 角色树</h4>\n<p>CabloyJS针对各类业务开发的需求，提炼了一套<code>内置角色</code>，并形成一个规范的<code>角色树</code>。实际开发中，可通过对<code>角色树</code>的扩充和调整，满足各类角色相关的需求</p>\n<ul>\n<li>root\n<ul>\n<li>anonymous</li>\n<li>authenticated\n<ul>\n<li>template</li>\n<li>registered</li>\n<li>activated</li>\n<li>superuser</li>\n<li>organization\n<ul>\n<li>internal</li>\n<li>external</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>root</td>\n<td>角色根节点，包含所有角色</td>\n</tr>\n<tr>\n<td>anonymous</td>\n<td><code>匿名</code>角色，凡是没有登录的用户自动归入<code>匿名</code>角色</td>\n</tr>\n<tr>\n<td>authenticated</td>\n<td><code>认证</code>角色</td>\n</tr>\n<tr>\n<td>template</td>\n<td><code>模版</code>角色，可为模版角色配置一些基础的、通用的权限</td>\n</tr>\n<tr>\n<td>registered</td>\n<td><code>已注册</code>角色</td>\n</tr>\n<tr>\n<td>activated</td>\n<td><code>已激活</code>角色</td>\n</tr>\n<tr>\n<td>superuser</td>\n<td><code>超级用户</code>角色，如用户<code>root</code>属于<code>超级用户</code>角色</td>\n</tr>\n<tr>\n<td>organization</td>\n<td><code>组织</code>角色</td>\n</tr>\n<tr>\n<td>internal</td>\n<td><code>内部组织</code>角色，如可添加<code>软件部</code>、<code>财务部</code>等子角色</td>\n</tr>\n<tr>\n<td>external</td>\n<td><code>外部组织</code>角色，可为合作伙伴提供角色资源</td>\n</tr>\n</tbody>\n</table>\n<h3>4.3 API接口权限</h3>\n<p>CabloyJS是前后端分离的模式，对<code>API接口权限</code>的控制需求就提升到一个更高的水平。CabloyJS提供了一个非常自然直观的权限控制方式</p>\n<p>比如模块<code>egg-born-module-a-baseadmin</code>有一个API接口<code>role/children</code>，是要查询某角色的子角色清单。这个API接口只允许管理员用户访问，我们可以这样做</p>\n<h4>4.3.1 功能与API接口的关系</h4>\n<p>我们把需要授权的对象抽象为<code>功能</code>。这样处理有一个好处：就是一个<code>功能</code>可以绑定1个或多个<code>API接口</code>。当我们对一个<code>功能</code>赋予了权限，也就对这一组绑定的<code>API接口</code>进行了访问控制</p>\n<h4>4.3.2 功能定义</h4>\n<p>先定义一个<code>功能</code>：<code>role</code></p>\n<p><code>egg-born-module-a-baseadmin/backend/src/meta.js</code></p>\n<pre class="prettyprint language- javascript"><code>...\n      functions: {\n        role: {\n          title: &#x27;Role Management&#x27;,\n        },\n      },\n...  \n</code></pre><h4>4.3.3 功能绑定</h4>\n<p>再将<code>功能</code>与<code>API接口</code>绑定</p>\n<p><code>egg-born-module-a-baseadmin/backend/src/routes.js</code></p>\n<pre class="prettyprint language- javascript"><code>...\n  { method: &#x27;post&#x27;, path: &#x27;role&#x2F;children&#x27;, controller: role,\n  meta: { right: { type: &#x27;function&#x27;, name: &#x27;role&#x27; } }\n},\n...\n</code></pre><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>right</td>\n<td>全局中间件<code>right</code>，默认处于开启状态，只需配置参数即可</td>\n</tr>\n<tr>\n<td>type</td>\n<td><code>function</code>: 判断功能授权</td>\n</tr>\n<tr>\n<td>name</td>\n<td>功能的名称</td>\n</tr>\n</tbody>\n</table>\n<h4>4.3.4 功能授权</h4>\n<p>接下来，我们就需要把功能<code>role</code>授权给角色<code>superuser</code>，而管理员用户归属于角色<code>superuser</code>，也就拥有了访问API接口<code>role/children</code>的权限</p>\n<p><code>功能授权</code>有两种途径：</p>\n<ol>\n<li>调用API直接授权</li>\n<li>CabloyJS已经实现了功能授权的管理界面：用管理员身份登录系统，进入<code>工具</code> &gt; <code>功能权限管理</code>，进行授权配置即可</li>\n</ol>\n<h3>4.4 数据访问权限</h3>\n<p>前面谈到，针对各类业务数据，CabloyJS抽象出来<code>原子</code>的概念。对<code>数据访问</code>授权，也就是对<code>原子授权</code></p>\n<p><code>原子授权</code>主要解决这类问题：<code>谁</code>能对<code>哪个范围内</code>的<code>原子数据</code>执行<code>什么操作</code>，基本格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>角色</th>\n<th>原子类型</th>\n<th>原子指令</th>\n<th>资源范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>superuser</td>\n<td>todo</td>\n<td>read</td>\n<td>财务部</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>角色<code>superuser</code>仅能读取<code>财务部</code>的<code>todo</code>数据</p>\n</blockquote>\n<p>更详细信息，强烈建议<a href="https://cabloy.com/zh-cn/articles/c38a1e24e5e343089deae4f550c6c0ec.html">参见</a></p>\n<h3>4.5 简单流程</h3>\n<p>在实际的业务开发中，难免会遇到一些流程需求。比如，CMS中的文章，在作者提交之后，可以转入审核员进行审核，审核通过之后方能发布</p>\n<p>当原子数据进入流程时，在不同的节点，处于不同的状态（审核中、已发布），只能由指定的角色进行节点的操作</p>\n<p>CabloyJS通过<code>原子标记</code>和<code>原子指令</code>的配合实现了一个简单的流程机制。也就是说，对于大多数简单流程场景，不需要复杂的<code>流程引擎</code>，就可以在CabloyJS中很轻松的实现</p>\n<p>更详细信息，强烈建议<a href="https://cabloy.com/zh-cn/articles/bdfb368793994e9990af6b9827c894d0.html">参见</a></p>\n<h2>5 解决方案</h2>\n<p>前面说到CabloyJS研发经历了两个阶段：</p>\n<ol>\n<li>EggBornJS</li>\n<li>CabloyJS</li>\n</ol>\n<p>如果说还有第三阶段的话，那就是<code>解决方案</code>阶段。EggBornJS构建了完整的NodeJS全栈开发体系，CabloyJS提供了大量面向业务开发的核心模块。那么，在EggBornJS和CabloyJS的基础上，接下来就可以针对不同的业务场景，研发相应的<code>解决方案</code>，解决实际的业务问题</p>\n<h3>5.1 Cabloy-CMS</h3>\n<p>CabloyJS是一个单页面、前后端分离的框架，而有些场景（如<code>博客</code>、<code>社区</code>等）更看重SEO、静态化</p>\n<p>CabloyJS针对这类场景，专门开发了一个模块<code>egg-born-module-a-cms</code>，提供了一套<code>文章静态渲染</code>的机制。CabloyJS本身天然的成为CMS的后台管理系统，从而形成<code>动静结合</code>的特点，主要特性如下：</p>\n<ul>\n<li>内置多站点、多语言支持</li>\n<li>不同语言可单独设置主题</li>\n<li>内置SEO优化，自动生成Sitemap文件</li>\n<li>文章在线撰写、发布</li>\n<li>文章发布时实时渲染静态页面，不必整站输出，提升整体性能</li>\n<li>内置文章查看计数器</li>\n<li>内置评论系统</li>\n<li>内置全文检索</li>\n<li>文章可添加附件</li>\n<li>自动合并并最小化CSS和JS</li>\n<li>JS支持ES6语法，并在合并时自动Babel编译</li>\n<li>首页图片延迟加载，自动匹配设备像素比</li>\n<li>调试便捷</li>\n</ul>\n<p>具体信息，请<a href="https://cabloy.com/zh-cn/articles/cms-introduce.html">参见</a></p>\n<h3>5.2 Cabloy-Community</h3>\n<p>CabloyJS以CMS模块为基础，开发了一个社区模块<code>egg-born-module-cms-sitecommunity</code>，配置方式与CMS模块完全一样，只需选用不同的<code>社区主题</code>即可轻松搭建一个交流社区（论坛）</p>\n<h2>6 未来规划与社区建设</h2>\n<blockquote>\n<p>Atwood定律: 凡是可以用JavaScript来写的应用，最终都会用JavaScript来写</p>\n</blockquote>\n<p>CabloyJS未来规划的核心之一，就是持续输出高质量的<code>解决方案</code>，为提升广大研发团队的开发效率不懈努力</p>\n<p>CabloyJS以及所有核心模块均已开源，欢迎大家加入CabloyJS，发Issue，点Star，提PR，更希望您能开发更多的业务模块，共建CabloyJS的繁荣生态</p>\n<h2>7 名称由来</h2>\n<p>最后再来聊聊框架名称的由来</p>\n<h3>7.1 EggBornJS</h3>\n<p>这个名称的由来比较简单，因为有了Egg，所以就有了EggBorn。有一部动画片叫《天书奇谭》，里面的萌主就叫“蛋生”，我很喜欢看（不小心暴露了年龄😅）</p>\n<h3>7.2 CabloyJS</h3>\n<p>Cabloy来自蓝精灵的魔法咒语，只有拼对了Cabloy这个单词才会有神奇的效果。同样，CabloyJS是有关JS的魔法，基于模块的组合与生化反应，您将实现您想要的任何东西</p>\n<h2>8 结语</h2>\n<p>亲，您也可以拼对Cabloy吧！这可是神奇的魔法哟！</p>\n</div>', 'title': '一文读懂NodeJS全栈开发利器：CabloyJS（万字长文）', 'last_reply_at': '2019-06-03T03:12:35.037Z', 'good': false, 'top': false, 'reply_count': 2, 'visit_count': 557, 'create_at': '2019-06-02T14:42:03.587Z', 'author': { 'loginname': 'zhennann', 'avatar_url': 'https://avatars1.githubusercontent.com/u/24246985?v=4&s=120' } }, { 'id': '5cefa26852ccb64168ba8f11', 'author_id': '5cefa02e52ccb64168ba8ef9', 'tab': 'ask', 'content': '<div class="markdown-text"><p>很抱歉打扰一下大家，我最近在使用egg socket去实现一个私聊功能。\n查了很多网上的做法，普遍的做法是使用一个全局的变量，将每次客户端连接的socket对象保存起来。等到客户端需要发送消息的时候，再将socket对象取出发送消息。\n但是现在我有几个问题：\n1.egg是没有全局变量的，因为生产环境可能有多个实例，所以每个实例的全局变量不同。所以我不能单纯地将socket挂在app上。\n2.想使用redis去存储socket对象。但是socket存入后会变为字符串，无法重新转变为socket对象。\n由于这两个问题，导致我不知道怎么实现私聊功能。。\n或者egg有其他socket插件可以使用？\n跪求指点！（由于不想在egg的issue里发，所以发到这里试下</p>\n</div>', 'title': 'egg.socket.io实现私聊功能的一个问题', 'last_reply_at': '2019-06-03T03:11:25.054Z', 'good': false, 'top': false, 'reply_count': 8, 'visit_count': 738, 'create_at': '2019-05-30T09:29:12.040Z', 'author': { 'loginname': 'tingtingtinghuang', 'avatar_url': 'https://avatars1.githubusercontent.com/u/26655372?v=4&s=120' } }, { 'id': '5cf48ada95fcc914aa265750', 'author_id': '5abcb87152d7d3a8698a4921', 'tab': 'ask', 'content': '<div class="markdown-text"><p><strong>问题如下：</strong></p>\n<ul>\n<li>一条sql语句在主库上执行不到1秒，从库执行6秒多。</li>\n<li>用explain看遍历行数和索引等都是一样的。</li>\n<li>主库买的阿里云mysql5.6(8G四核),  从库自己在公网服务器（8G四核，只有mysql一个应用）搭的mysql5.6，且配置文件关键参数都修改得和主库一致</li>\n</ul>\n<p>想问一下有什么建议定位这个问题？</p>\n</div>', 'title': 'mysql 主从两库的查询性能差异问题', 'last_reply_at': '2019-06-03T03:06:59.946Z', 'good': false, 'top': false, 'reply_count': 1, 'visit_count': 209, 'create_at': '2019-06-03T02:50:02.468Z', 'author': { 'loginname': 'jacksparrow68', 'avatar_url': 'https://avatars0.githubusercontent.com/u/33364326?v=4&s=120' } }, { 'id': '5ce37234518e0954fc41017e', 'author_id': '5cd52169ce97fe69027a4165', 'tab': 'share', 'content': '<div class="markdown-text"><p>学习 node 的小伙伴相信都有一颗全栈的心, 虽然 node 全栈被 javaer 嘲笑, 但并不代表不行, 用狼叔话讲是 java 底子太厚, 给 node 发挥的机会不多</p>\n<p>我是一个 iOSer, 学习 node 的目的是为了扩展能力范围, 让自己没有短板, 假如被裁了, 离开了公司, 自己也可以  SOHO, 也算是给自己留个备胎, 毛衣站的事情告诉我们, 打铁还得自身硬,  备胎总比瘸腿强</p>\n<p>扯了这么多, 下面来说说我的计划吧</p>\n<p>我用半个月的时间学习了一下 node 的基础 api, 对 http, net, event, stream, fs, 这几个模块也挺熟悉了, 我在慕课网上买了一个视频, <a href="https://s.imooc.com/SOZks8k">Node.js 从零开发web server博客项目</a>, 看重这个课程是因为他主要讲后端工程师如何思考, 并且把一个博客项目用裸写, express, koa2 写了三遍, 可以从底层做起, 并且了解框架做了哪些事情以及优点, 知其然, 知其所以然</p>\n<p>前端课程我选了 b 站上的一个视频, <a href="https://www.bilibili.com/video/av47296993">React+Redux+React Router+Node.js全栈开发</a>, 本人之前写过 RN, 所以对 react + redux 还算熟. 另外, react 对 ts 天生友好,回头学习 ts 也可以无痛练习</p>\n<p>视频时长大概有 50 小时, 每天看一小时视频, 写一小时代码, 也每天将近两个小时, 强度感觉挺高了, 加上有时候会摸鱼, 感觉100 天搞完也挺紧张😂</p>\n<p>有跟我一样想提高自己却没有执行力的, 大家组个团, 互相监督打卡交流, 争取明年 30k!!!</p>\n<p>欢迎大家把自己的计划写到回复里, 加入 qq 群 542160608</p>\n</div>', 'title': '自己定了一个百天"全栈计划", 欢迎小伙伴们加入, 互相打卡监督', 'last_reply_at': '2019-06-03T02:53:58.182Z', 'good': false, 'top': false, 'reply_count': 18, 'visit_count': 1881, 'create_at': '2019-05-21T03:36:20.357Z', 'author': { 'loginname': 'Luyakus', 'avatar_url': 'https://avatars0.githubusercontent.com/u/16056733?v=4&s=120' } }, { 'id': '5cd0e0d2776fb66e0d172bb0', 'author_id': '5cac197b7edd13064e053b71', 'tab': 'share', 'content': '<div class="markdown-text"><p>ts是前端必备技能，此教程类 接口 泛型 泛型类、模块、装饰器都讲了，算是市面上最全的ts教程。 废话不多说 直接上地址。</p>\n<p><strong>2019年5月更新TypeScript入门实战教程B站地址:</strong></p>\n<p><a href="https://www.bilibili.com/video/av38379328/?p=1">https://www.bilibili.com/video/av38379328/?p=1</a></p>\n<p><strong>2019年5月更新TypeScript入门实战教程百度网盘地址:</strong></p>\n<p><a href="https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg">https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg</a></p>\n</div>', 'title': '2019年5月更新TypeScript入门实战教程-类 接口 泛型 泛型类 ts封装类似Mongoose的db库、装饰器-免费分享', 'last_reply_at': '2019-06-03T02:49:27.969Z', 'good': false, 'top': false, 'reply_count': 9, 'visit_count': 1968, 'create_at': '2019-05-07T01:35:14.483Z', 'author': { 'loginname': 'xiaofenlin', 'avatar_url': 'https://avatars3.githubusercontent.com/u/49425206?v=4&s=120' } }, { 'id': '54ab242ece87bace2444ca42', 'author_id': '5481716f3098e8df0a116fc4', 'tab': 'ask', 'content': '<div class="markdown-text"><p>现在的情况是运行了2个socket.io的聊天程序，使用了socket.io-redis，群聊的消息大家都能看得到，但是现在我想一对一的进行聊天，不知道怎么弄了，希望指导一下。就是A服务器的某一个用户怎么才能向B服务器的某一个用户发送消息呢？</p>\n</div>', 'title': '请问我用socket.io-redis可以实现广播，但是怎么实现一对一聊天呢？', 'last_reply_at': '2019-06-03T02:22:00.741Z', 'good': false, 'top': false, 'reply_count': 14, 'visit_count': 14742, 'create_at': '2015-01-05T23:54:22.532Z', 'author': { 'loginname': '330216851', 'avatar_url': 'https://avatars.githubusercontent.com/u/10084744?v=3&s=120' } }, { 'id': '5cf23efc1fe902120f31b2a5', 'author_id': '5cf23ead95fcc914aa2652bf', 'tab': 'share', 'content': '<div class="markdown-text"><p>github链接：<a href="https://github.com/ykfe/egg-react-ssr">https://github.com/ykfe/egg-react-ssr</a></p>\n<h1>Egg + React + SSR应用骨架</h1>\n<h1>Getting Start</h1>\n<p>这里我们提供了一个脚手架来方便你创建项目</p>\n<pre class="prettyprint"><code>\n$ npm install yk-cli -g\n$ ykcli init &lt;Your Project Name&gt;\n$ cd &lt;Your Project Name&gt;\n$ npm i\n$ npm start\n$ open http:&#x2F;&#x2F;localhost:7001\n\n</code></pre><h1>功能/特性</h1>\n<h2>已完成</h2>\n<ul>\n<li>基于cra脚手架开发，由cra开发的React App可无缝迁移，如果你熟悉cra的配置，上手成本几乎为0</li>\n<li>小而美，相比于beidou，next.js这样的高度封装方案，我们的实现原理和开发模式一目了然</li>\n<li>同时支持SSR以及CSR两种开发模式</li>\n<li>统一前端路由与服务端路由，无需重复编写路由文件配置</li>\n<li>支持切换路由时自动获取数据</li>\n<li>支持本地开发HMR</li>\n<li>稳定性经过线上大规模应用验证，可提供性能优化方案</li>\n<li>配套<a href="https://github.com/ykfe/egg-react-ssr-typescript">TypeScript</a>版本的实现</li>\n</ul>\n<h2>开发中</h2>\n<ul>\n<li>配套serverless版本的实现</li>\n</ul>\n<h1>获取数据</h1>\n<p>定义组件的静态方法getInitialProps，获取数据的逻辑将统一在这个方法中执行。</p>\n<p>当页面初始化加载时，getInitialProps只会加载在服务端。只有当路由跳转（Link组件跳转或 API 方法跳转）时，客户端才会执行getInitialProps。</p>\n<p>注意：getInitialProps将不能使用在子组件中。只能使用在pages页面中。</p>\n<p>getInitialProps入参对象的属性如下：</p>\n<p>ctx: Node应用请求的上下文(仅在SSR阶段可以获取)</p>\n<p>Router Props: 路由信息，包括pathname以及Router params等信息，详细信息参考react-router文档(需使用withRouter高阶组件)</p>\n<h1>目录结构</h1>\n<pre class="prettyprint"><code>\n.\n├── README.md\n├── app &#x2F;&#x2F; egg核心目录\n│   ├── controller\n│   ├── extend\n│   ├── middleware\n│   └── router.js &#x2F;&#x2F; egg路由文件，无特殊需求不需要修改内容\n├── app.js &#x2F;&#x2F; egg 启动入口文件\n├── build &#x2F;&#x2F; webpack配置目录\n│   ├── env.js\n│   ├── jest\n│   ├── paths.js\n│   ├── util.js\n│   ├── webpack.config.base.js &#x2F;&#x2F; 通用的webpack配置\n│   ├── webpack.config.client.js &#x2F;&#x2F; webpack客户端打包配置\n│   └── webpack.config.server.js &#x2F;&#x2F; webpack服务端打包配置\n├── config &#x2F;&#x2F; egg config\n│   ├── config.daily.js\n│   ├── config.default.js\n│   ├── config.local.js\n│   ├── config.prod.js\n│   ├── config.staging.js\n│   ├── plugin.js\n│   └── plugin.local.js\n├── dist &#x2F;&#x2F; build生成静态资源目录\n│   ├── Page.server.js &#x2F;&#x2F; 服务端打包后文件(即打包后的serverRender方法)\n│   └── static &#x2F;&#x2F; 前端打包后静态资源目录\n└── web\n    ├── assets\n    │   └── common.less\n    ├── entry.js &#x2F;&#x2F; webpack打包入口文件，分环境导出不同配置\n    ├── index.html &#x2F;&#x2F; 页面骨架模版\n    ├── layout\n    │   ├── index.js &#x2F;&#x2F; 页面布局\n    │   └── index.less\n    └── page\n        ├── index\n        └── news\n\n</code></pre><h1>npm scripts</h1>\n<pre class="prettyprint"><code>\n$ npm start &#x2F;&#x2F; 启动监听7001端口，建议使用方式，同时启动服务端渲染 + 客户端水合\n$ npm run ssr &#x2F;&#x2F; 启动监听7001端口，只启动服务端渲染，此时仅服务端直出html，没有与客户端混合的步骤\n$ npm run csr &#x2F;&#x2F; 启动监听8000端口，只启动客户端渲染，相当于传统的cra脚手架开发模式\n$ npm run prod &#x2F;&#x2F; 模拟SSR应用生产环境\n$ npm run build &#x2F;&#x2F; 打包服务端以及客户端资源文件\n$ npm run ananlyze &#x2F;&#x2F; 可视化分析客户端打包的资源详情\n\n</code></pre><h1>config.default.js 文件配置</h1>\n<p>为了足够灵活使用，这里我们将一些关键项提供可配置的选项，可根据实际需要来配置，如无特殊必要，使用默认配置即可。</p>\n<pre class="prettyprint"><code>\nconst resolvePath = (path) =&gt; require(&#x27;path&#x27;).resolve(process.cwd(), path)\n\nmodule.exports = {\n    keys: &#x27;eggssr&#x27;,\n    static: {\n        &#x2F;&#x2F; 设置Node应用的静态资源目录，为了生产环境读取静态资源文件\n      prefix: &#x27;&#x2F;&#x27;,\n      dir: resolvePath(&#x27;dist&#x27;)\n    },\n    routes: [\n        &#x2F;&#x2F; 前后端统一使用的路由配置文件，防止重复编写相同的路由\n      {\n        path: &#x27;&#x2F;&#x27;, &#x2F;&#x2F; 请求的path\n        exact: true, &#x2F;&#x2F; 是否精确匹配\n        Component: () =&gt; (require(&#x27;@&#x2F;page&#x2F;index&#x27;).default), &#x2F;&#x2F; 这里使用一个function包裹为了让它延迟require, 否则Node环境无法识别前端组件中用到的import关键字会报错\n        controller: &#x27;page&#x27;, &#x2F;&#x2F; 需要调用的controller\n        handler: &#x27;index&#x27; &#x2F;&#x2F; 需要调用的controller中具体的method\n      },\n      {\n        path: &#x27;&#x2F;news&#x2F;:id&#x27;,\n        exact: true,\n        Component: () =&gt; (require(&#x27;@&#x2F;page&#x2F;news&#x27;).default),\n        controller: &#x27;page&#x27;,\n        handler: &#x27;index&#x27;\n      }\n    ],\n    template: resolvePath(&#x27;web&#x2F;index.html&#x27;), &#x2F;&#x2F; 使用的模版文件路径\n    injectCss: (chunkName) =&gt; ([\n      &#96;&#x2F;static&#x2F;css&#x2F;${chunkName}.chunk.css&#96;\n    ]), &#x2F;&#x2F; 客户端需要加载的静态css文件资源\n    injectSrcipt: (chunkName) =&gt; ([\n      &#96;&lt;script src=&#x27;&#x2F;static&#x2F;js&#x2F;runtime~${chunkName}.js&#x27;&gt;&lt;&#x2F;script&gt;&#96;,\n      &#96;&lt;script src=&#x27;&#x2F;static&#x2F;js&#x2F;vendor.chunk.js&#x27;&gt;&lt;&#x2F;script&gt;&#96;,\n      &#96;&lt;script src=&#x27;&#x2F;static&#x2F;js&#x2F;${chunkName}.chunk.js&#x27;&gt;&lt;&#x2F;script&gt;&#96;\n    ]), &#x2F;&#x2F; 客户端需要加载的静态js文件资源\n    serverJs: (chunkName) =&gt; resolvePath(&#96;dist&#x2F;${chunkName}.server.js&#96;) &#x2F;&#x2F; 服务端需要使用的打包后的serverRender方法js文件的路径\n}\n\n\n</code></pre><h1>执行流程</h1>\n<p><img src="https://gw.alicdn.com/tfs/TB11BwkX8Gw3KVjSZFDXXXWEpXa-2050-1502.jpg" alt></p>\n<h1>答疑群</h1>\n<p>虽然我们已经尽力检查了一遍应用，但仍有可能有疏漏的地方，如果你在使用过程中发现任何问题或者建议，欢迎提<a href="https://github.com/ykfe/egg-react-ssr/issues">issue</a>或者<a href="https://github.com/ykfe/egg-react-ssr/pulls">PR</a>\n欢迎直接扫码加入钉钉群\n<img src="https://img.alicdn.com/tfs/TB12afNba1s3KVjSZFAXXX_ZXXa-300-396.jpg" alt></p>\n</div>', 'title': '最小而美的Egg + React + SSR应用骨架', 'last_reply_at': '2019-06-03T01:47:26.394Z', 'good': false, 'top': false, 'reply_count': 0, 'visit_count': 409, 'create_at': '2019-06-01T09:01:48.611Z', 'author': { 'loginname': 'zhangyuang', 'avatar_url': 'https://avatars3.githubusercontent.com/u/17424434?v=4&s=120' } }] }
